[Legenda]
op : Operator
fnc: Function
flw: Flow
cst: Constant


< CORE - LIB 
[*] () sPOWER-KI : 

< DESCRIPTION 
< MANAGED 
< STATUS 
< DISTRIBUTION - USE: AVAILABILITY
< IDENTIFICATION 
< REVISION 
< N° - USE: DATE
< N° - USE: DATE
< N° - USE: DATE
< Glossary entry - USE: Entry definition
< Text - USE: Description
[*] (op 1) REF : Instruct PWK to use the parameter as a symbol

< 1.REF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ELEMENT|symb||||

[RETURN|TYPE|VALUES|COMMENT]
VAL|symb.|

[EXAMPLE]
A_01=”pippo”;

B=ref(“A”++”_01”);              >>> b=pippo
ref(“A”++”_01”)=”papero”;       >>> A_01=papero
>


[*] (op 1) NNL : Never Null - if element is null an empty literal is returned instead
Related: NNLv (as Function)

< 1.NNL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ELEMENT|symb||||

[RETURN|TYPE|VALUES|COMMENT]
VAL|symb.|

[EXAMPLE]
A= NULL;

A= NNL A ==> A==£
>


[*] (fnc) NNLv : Never Null - if element is null an empty literal or the provided substitute is returned instead
Related: NNL (as operator)

< 1.NNLv 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ELEMENT|symb||||
SUBSTITUTE|symb|||£|

[RETURN|TYPE|VALUES|COMMENT]
VAL|symb.|

[EXAMPLE]
NNLv("Pippo")    >>> "Pippo"
NNLv(" ")        >>> " "
NNLv(NULL)       >>> £ ( same as "" )

NNLv(a, "1")     >>> if a is null, 1, else value of 'a'
>


[*] (fnc) EXIST : Return the address of a £itteral if Exists
Remark: is the same as  $(ref( …)) but if the ELEMENT doesn't exists no error is output on cnserr

< 1.EXIST 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ELEMENT|symb||||

[RETURN|TYPE|VALUES|COMMENT]
VAL|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|NULL|

[EXAMPLE]
Main has only 1 attribute: tmp 
EXIST("tmp@\Main") >>> Positive integer value (attribute pointer, $tmp@\Main)
EXIST("cnd@\Main") >>> NULL
>


[*] (fnc) CACHERST : Reset the thread symbol cache
Remark: No return value

< 1.CACHERST 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]
>


[*] (fnc) TYPOF : if exist return the type of an Item passed as a litteral

< 1.TYPOF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ELEMENT|symb||||

[RETURN|TYPE|VALUES|COMMENT]
VAL|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|NULL|

[EXAMPLE]
In the program there is a VAR DATA, containing the MTHD sumClc
TYPOF("\DATA\sumClc")             >> £MTHD
>


[*] (flw) #IF : Evaluate a condition if true, the following statements, till #ELSE or #ELSE_OTIF or #END are executed, if false and exists an #ELSE or #ELSE_OTIF, that block of code is executed
Related: #ELSE, #ELSE_OTIF, #END, #WHILE, #BREAK, #SKIP
Remark: if more parameter are passed  only the last is evaluated  for execution, IF alone is the assignment function

< 1.#IF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
CONDITION|symb||||

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
#IF(a>10); CHATput(“Greater”); #ELSE; CHATput(“Lesser”); #END; CHATput(“End”) ;

#IF(a=a+1, a>10); CHATput(“Greater”);#end;
>


[*] (flw) #ELSE : Inside an #IF block, the code between #ELSE and #END is executed, if the condition is false
Related: #IF, #END, #WHILE , #BREAK, #SKIP
Remark: IF alone is the assignment function

< 1.#ELSE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
#IF(a>10); CHATput(“ Maggiore”); #ELSE; CHATput(“ Minore”); #END;  put(“ Fine”)
>


[*] (flw) #ELSE_OTIF : Inside an #IF block, the code between #ELSE_OTIF and #END is executed, if the condition is false  Or , if the #IF condition is TRUE and the #ELSE_OTIF condition is also true.
Related: #IF, #END, #WHILE , #BREAK, #SKIP
Remark: OTIF = Or Then IF

< 1.#ELSE_OTIF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
#if( a );
... chatput( £IF_done);
#else_otif( b ) ; !! opzionale;
... chatput( £ELSE_done);
#end;
with a=0 : ELSE_done
with a=1 e b=0; IF_done
with a=1 e b=1: IF_done ELSE_done
>


[*] (flw) #WHILE : the code between #WHILE and #END is executed, if the condition of #WHILE is true
Related: #IF, #END, #ELSE, #BREAK, #SKIP
Remark: if more parameter are passed  only the last is evaluated  for execution,

< 1.#WHILE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
CONDITION|symb||||

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
a=0;
#WHILE(a<10); a=a+1; #END; CHATput(“ Fine”) ;
a=0;
#WHILE(a=a+1, a<10); CHATput(“>”,a);#end;
>


[*] (flw) #BREAK : break a #WHILE
Related: #IF, #WHILE,  #ELSE,  #SKIP, #END

< 1.#BREAK 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
a=0;
#WHILE(a<10); a=a+1;  
       #IF(a==5); #BREAK;  #END; 
#END;
>


[*] (flw) #SKIP : Continue a While without execute the trailing code
Related: #IF, #WHILE,  #ELSE,  #END, #BREAK

< 1.#SKIP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
a=0;b=0
#WHILE(a<10); 
    a=a+1;  
    #IF(a==5); 
        #SKIP;  
    #END; 
    b=b+1;
#END;             >>> a=10, b=9;
>


[*] (flw) #END : mark the end of a block of code inside an #IF, #ELSE, #WHILE
Related: #IF, #WHILE,  #ELSE, #BREAK, #SKIP

< 1.#END 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
a=0;
#WHILE(a<10); a=a+1; #END; CHATput(“ Fine While”) ;

#IF(a>10); CHATput(“ Maggiore”); #ELSE; CHATput(“ Minore”); #END; CHATput(“ Fine If”) ;
>


[*] (op 18) -> : Right assigmnet
Remark: pop value from the stack and assign to symbol, should be used by MRF

< 1.-> 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
!!you can write;
A=1+2;
!!but also;
1+2 -> A;

l=LIS_NEW(1,2,3);
LIS_USE(l)->a->b->c;      >>> a=3 b=2 c=1
a=LIS_USE(l)->b->c        >>> a=1 b=3 c=2

a=LIS_USE(l);             >>> not working, 2 pars are unmanaged
LIS_USE(l)->b->c;         >>> b=3 c=2, 1 elem. remains in stack,but it's cleared on ';'
>


[*] (fnc) CALL : Inline execution of a CALL to a BLK
Related: :: ? EXC EXCTHR EXOMKR
Remark: Is a MRF

< 1.CALL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BLK|symb||||
PAR|slis||set(::) or get(?) parameter||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb.|

[OnError|TYPE|VALUES|COMMENT]
ERR|NULL|

[EXAMPLE]
BLK is a block that return c=a+b:
r=CALL( £\SUM, a:: 5, b:: 6, ?c); ==>  internally c=11, so r=11
>


[*] (fnc) EXC : Inline execution of an EXO
Related: :: ? EXCTHR EXOMKR CALL
Remark: Is a MRF

< 1.EXC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
EXO|symb||||
PAR|slis||set(::) or get(?) parameter||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb.|NULL

[EXAMPLE]
SUM is a method that return c=a+b:
r=EXC( £\SUM, a:: 5, b:: 6, ?c); ==>  internally c=11, so r=11

TEST is a method that pass through the values from SET to GET:
ra=EXC( £\TEST, a:: 8, b:: 7, c::6, ?a,?b, ?c) -> rc -> rb ; ==> ra=8   rb=7  rc=6
>


[*] (fnc) EXCTHR : Inline startr execution of an EXO in a new Thread
Related: :: ? EXC CALL

< 1.EXCTHR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
EXO|symb||||
PAR|slis||set(::)||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
ERR|NV|-1

[EXAMPLE]
r=EXOTHR( £\TEST, a:: 8, b:: 7, c::6) ;

A _PAR_ can be defined with the same values of the THREAD item : SYNC ONCE ONCE_FOR_CALLER

r=EXOTHR( £\TEST, a:: 8, b:: 7, c::6, _PAR_::£ONCE);
>


[*] (fnc) EXO : Inline execution of an EXO – DEPRECATED use EXC !
Related: :: ? EXOTHR EXOMKR
Remark: Is a MRF

< 1.EXO 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
EXO|symb||||
PAR|slis||set(::) or get(?) parameter||

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
SUM is a method that return c=a+b:
r=EXO( £\SUM, a:: 5, b:: 6, ?c); ==>  internally c=11, so r=11

TEST is a method that pass through the values from SET to GET:
ra=EXO( £\TEST, a:: 8, b:: 7, c::6, ?a,?b, ?c) -> rc -> rb ; ==> ra=8   rb=7  rc=6
>


[*] (fnc) EXOTHR : Inline startr execution of an EXO in a new Thread  – DEPRECATED use EXCTHR !
Related: :: ? EXO
Remark: Is a MRF

< 1.EXOTHR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
EXO|symb||||
PAR|slis||set(::)||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
ERR|NV|-1

[EXAMPLE]
r=EXOTHR( £\TEST, a:: 8, b:: 7, c::6) ;

A _PAR_ can be defined with the same values of the THREAD item : SYNC ONCE ONCE_FOR_CALLER

r=EXOTHR( £\TEST, a:: 8, b:: 7, c::6, _PAR_::£ONCE);
>


[*] (fnc) EXOMKR : EXO maker : create a persistent EXO and return its pointer suitable to be used by EXO()
Related: :: ? EXO
Remark: After the use should be TRASHED -

< 1.EXOMKR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
EXO|symb||EXO name to call||

[RETURN|TYPE|VALUES|COMMENT]
PTR|N.A.|

[OnError|TYPE|VALUES|COMMENT]
ERR|N.A.|NULL

[EXAMPLE]
SUM is a method that return c=a+b:
ep=EXOMKR(£\SUM);
r=EXO( ep, a:: 5, b:: 6, ?c); ==>  internally c=11, so r=11

TRASH(ep); !!Do Not forget;

!!method of an EXO created with EXOMKR can be invoked chaining the pointer with the method name:
EXO(ep.."ExoMethod", p1:: ...
>


[*] (fnc) EXOFLUSH : Flush EXO cache
Related: EXO

< 1.EXOFLUSH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
Used modifying the program itself with the TREE functions: EXOFLUSH eliminates the cache of previous executions, to ensure that the last modified version is executed
>


[*] (sep) !! : Denote the beginning of a comment. End with semi colon.
Colour the comment in GREEN.
Related: !!!
Remark: you can inline comment in statement : x= alfa !!example; * beta !!example; ; (remember to close the statement with a semi colon);

[*] (sep) !!! : Denote the beginning of a comment. End with semi colon.
Colour the comment in BLUE.
Related: !!
Remark: you can inline comment in statement : x= alfa !!!example; * beta !!example; ; (remember to close the statement with a semi colon);

[*] (op 1) $ : Symbol address
Related: WAITCND, GUI_EXCMSG

< 1.$ 
>


[*] (op 0) £ : Literal. The following symbol is considered as surrounded by double quote (no white spaces are allowed between caracter)

< 1.£ 
>


[*] (op0) :: : EXO set parameter at the END of a symbol - the symbol is considered as literal
Related: EXO ?
Remark: status:: 5 Note MUST be followed by a value - alone is a separator like comma

[*] (op0) ? : EXO get parameter at the Beginning of a symbol - the symbol is considered as literal
Related: EXO,::
Remark: ?status

[*] (sep) ( ) : Contains function parameters (if more then one separated by comma)
Related: cat( pippo,pluto,paperino);

[*] (sep) [ ] : Contains the index of a matrix element.
Related: Matrice[a,b,c];

[*] (op) { } : Indirect reference to a symbol.
Remark: each couple of parenthesis represent  a level of indirection

< 1.{ } 
>


[*] (op 2) ~ : Check a symbol against NULL or empty.

< 1.~ 
>


[*] (op 20) = : Assignment operator

< 1.= 
>


[*] (op 2) // : Integral division
Related: MOD
Remark: division by 0 gives 0

< 1.// 
>


[*] (op 3) MOD : Integral division rest operator
Related: //

< 1.MOD 
>


[*] (op 1) ABS : Absolute value

< 1.ABS 
>


[*] (op 3) / : Division
Remark: division by 0 gives 0

[*] (op 4) + : Sum

[*] (op 4) - : Subtraction operator or minus sign.

[*] (op 4) += : Atomic Increment
Related: += SMF
Remark: the Left synbol (LV) is incremented by the RV, the assignment is Thread safe

[*] (op 4) -= : Atomic decrement
Related: -=, SMF
Remark: the Left synbol (LV) is decremented by the RV, the assignment is Thread safe

[*] (op 3) * : Multiplication operator.

[*] (op 7) == : Compare for equality.
Related: EQ
Remark: If NNV are involved the comparison is case insensitive and the space at the begin and at the end of the value are ignored. For exact comparison use CMP operator.

< 1.== 
>


[*] (cst) TRUE : Return 1
Related: ==

< 1.TRUE 
>


[*] (cst) FALSE : Return 0
Related: ==

< 1.FALSE 
>


[*] (fnc) RAND : Random generated number (FLT) between 0 and 10000

< 1.RAND 
>


[*] (fnc) UID : A unic id built chaining:  clock_cnt
Remark: It is granted to be unic inside the application and Thread safe

< 1.UID 
>


[*] (fnc) UCNT : A unic counter incremented at each call
Remark: It is granted to be unic inside the application and Thread safe

< 1.UCNT 
>


[*] (cst) DBGLINE : Return the current code line

< 1.DBGLINE 
>


[*] (op 7) EQ : Compare for equality
Related: ==
Remark: If NNV are involved the comparison is case insensitive and the space at the begin and at the end of the value are ignored. For exact comparison use CMP operator.

< 1.EQ 
>


[*] (op 2) != : Compare for inequality.
Related: NE , <> DEPRECATED
Remark: If NNV are involved the comparison is case insensitive and the space at the begin and at the end of the value are ignored. For exact comparison use CMP operator.

< 1.!= 
>


[*] (op 7) NE : Compare for inequality.
Related: !=
Remark: If NNV are involved the comparison is case insensitive and the space at the begin and at the end of the value are ignored. For exact comparison use CMP operator.

< 1.NE 
>


[*] (op 6) < : compare for Less then
Related: LT

< 1.< 
>


[*] (op 6) LT : compare for Less then
Related: <

< 1.LT 
>


[*] (op 6) > : Compare for Greater Then
Related: GT

< 1.> 
>


[*] (op 6) GT : Compare for Greater Then
Related: <

< 1.GT 
>


[*] (op 6) <= : compare for Less or equal then
Related: LE

< 1.<= 
>


[*] (op 6) LE : compare for Less or equal then
Related: <=

< 1.LE 
>


[*] (op 6) >= : compare for Greater or Equal then
Related: GT

< 1.>= 
>


[*] (op 6) GE : compare for Greater or Equal then
Related: >=

< 1.GE 
>


[*] (op 8) & : binary AND

< 1.& 
>


[*] (op 10) | : binary OR

< 1.| 
>


[*] (op 9) % : binary XOR

< 1.% 
>


[*] (op 1) ^ : Power

< 1.^ 
>


[*] (fnc) SQRT : Sqare Root
Remark: If par1 is negative, SQRT returns 0

< 1.SQRT 
>


[*] (cst) ENP : return Neperian value
Related: EXP,LOG
Remark: Neperian value (2.7...)

[*] (fnc) EXP : Calculate neperian exponent
Related: ENP,LOG

< 1.EXP 
>


[*] (fnc) LOG : Calculate neperian logarithm
Related: ENP,EXP

< 1.LOG 
>


[*] (fnc) LOG10 : Calculate 10 based logarithm
Related: ENP, EXP, LOG

< 1.LOG10 
>


[*] (op 2) ! : NOT operator

< 1.! 
>


[*] (OP 5) << : Left shift
Related: LSHF

< 1.<< 
>


[*] (OP 5) LSHF : Left shift
Related: <<

< 1.LSHF 
>


[*] (op 5) >> : Right Shift
Related: RSHF

< 1.>> 
>


[*] (op 5) RSHF : Right Shift
Related: >>

< 1.RSHF 
>


[*] (op 14) <<= : Concatenate symbol
Related: .. , ++
Remark: same as ++

< 1.<<= 
>


[*] (op 14) ++ : Concatenate symbol
Related: .. , <<=
Remark: same as <<=

< 1.++ 
>


[*] (op 14) .. : Concatenate symbol with a space between
Related: <<=

< 1... 
>


[*] (op 2) NOT : LOGICAL NOT
Related: !

< 1.NOT 
>


[*] (op 11) AND : LOGICAL AND

< 1.AND 
>


[*] (op 13) OR : LOGICAL OR

< 1.OR 
>


[*] (op 12) XOR : LOGICAL XOR

< 1.XOR 
>


[*] (fnc) SWAP : swap a symb BYTE,WORD, DWORD

< 1.SWAP 
>


[*] (fnc) MIN : Minimum value of a list of values
Related: MAX

< 1.MIN 
>


[*] (fnc) MAX : maximum value of a list of values
Related: MIN

< 1.MAX 
>


[*] (fnc) LIM : Constraint a value between limit
Related: MIN, MAX
Remark: For MIN and MAX a NULL value prevent the relative comparison

< 1.LIM 
>


[*] (fnc) IF : ternary IF assignment
Remark: if val1 or and if val2 are statement they are always executed

< 1.IF 
>


[*] (cst) PI : Return greeck pi value 3.1412...)

[*] (fnc) TANH : Hyperbolic Tangent

< 1.TANH 
>


[*] (fnc) SINH : Hyperbolic Sin

< 1.SINH 
>


[*] (fnc) COSH : Hyperbolic Cos

< 1.COSH 
>


[*] (fnc) ATAN : Arc of tangent

< 1.ATAN 
>


[*] (fnc) ATAN2 : Returns the principal value of the arc tangent of y/x, expressed in radians.

< 1.ATAN2 
>


[*] (fnc) ASIN : Arc of sinus

< 1.ASIN 
>


[*] (fnc) ACOS : Arc of cosinus

< 1.ACOS 
>


[*] (fnc) TAN : Tangent

< 1.TAN 
>


[*] (fnc) SIN : Sinus of angle

< 1.SIN 
>


[*] (fnc) COS : the co-sinus of angle

< 1.COS 
>


[*] (fnc) BITF : set or get a bit field
Remark: Numbering of bit from right to left, from 1 to 32

< 1.BITF 
>


[*] (fnc) HEX : Convert NV in hexadecimal representation prefixed by OX.

< 1.HEX 
>


[*] (fnc) BIN : Convert NV in binary representation prefixed by OB.

< 1.BIN 
>


[*] (fnc) FLT : Convert NV in float with a specified number of fractional digit.
Remark: FLT is different from TRUNCATE in that it approximates the closest value both by excess and by defect

< 1.FLT 
>


[*] (fnc) INT : Convert NV to integer

< 1.INT 
>


< 2.INT - USE: Type or rounding for float
>


[*] (fnc) UNS : Convert NV to unsigned

< 1.UNS 
>


[*] (fnc) CHAR : Encode a list of NV as Char and return a symbol of concatenated values

< 1.CHAR 
>


[*] (fnc) CHARCOD : Return the NV of a symb character

< 1.CHARCOD 
>


[*] (fnc) FRMT : Format a string with the behavior of C printf
Remark: slist SHOULD  match the type requested by format

< 1.FRMT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
format|symb||formed with C printf notation||
...|slist||list of symbol||

[RETURN|TYPE|VALUES|COMMENT]
rslt|symb|

[EXAMPLE]
a=12;
FRMT(“Valore %d”,a);    >>>    “Valore 12”
FRMT("Characters: %c %c \n", 'a', 65);    >>>    Characters: a A

FRMT("Decimals: %d %ld\n", 1977, 650000);
          >>>    Decimals: 1977 650000

FRMT("Preceding with blanks: %10d \n", 1977);
          >>>    Preceding with blanks:       1977

FRMT("Preceding with zeros: %010d \n", 1977);
          >>>    Preceding with zeros: 0000001977

FRMT("Some different radixes: %d %x %o %#x %#o        \n",100,100,100,100,100);
          >>>    Some different radixes: 100 64 144 0x64 0144

FRMT("floats: %4.2f %+.0e %E \n", 3.1416, 3.1416, 3.1416);
          >>>    floats: 3.14 +3e+000 3.141600E+000

FRMT("Width trick: %*d \n", 5, 10);
          >>>    Width trick:    10

FRMT("%s \n", "A string");
          >>>    A string

FRMT("%04X", 11)
         >>>    000B
>


[*] (cst) NULL : return a NULL symbol

[*] (fnc) TSTX : Test a condition and return left (TRUE) or right(FALSE) value

< 1.TSTX 
>


[*] (fnc) ISNULL : Verify if parameter is NULL
Related: ISEMPTY, ISTRUE, ~

< 1.ISNULL 
>


[*] (fnc) ISEMPTY : Verify if parameter is EMPTY (no contents or all spaces)
Related: ISNULL, ISTRUE, ~

< 1.ISEMPTY 
>


[*] (fnc) ISTRUE : Verify if parameter is TRUE
Related: ISNULL, ISEMPTY, ~
Remark: NV are true if  not NULL or 0; NNV are true if not NULL or EMPTY

< 1.ISTRUE 
>


[*] (fnc) ISERR : Verify if PAR is ERROR (NULL or <0)

< 1.ISERR 
>


[*] (fnc) ISNUM : test par to verify if it is a number

< 1.ISNUM 
>


[*] (fnc) ISFLT : test par to verify if it is a float

< 1.ISFLT 
>


[*] (fnc) QUOS : Single quote
Related: QUOD,QUOSE,QUODE,ESCP

< 1.QUOS 
>


[*] (fnc) QUOD : Double quote
Related: QUOS,QUOSE,QUODE,ESCP

< 1.QUOD 
>


[*] (fnc) QUOSE : Single quote and Escape doubling the single quote
Related: QUOS,QUOD,QUODE,ESCP

< 1.QUOSE 
>


[*] (fnc) QUODE : Double quote and Escape doubling the double quote
Related: QUOS,QUOD,QUOSE,ESCP

< 1.QUODE 
>


[*] (fnc) ESCP : Escape a character in a symbol
Related: QUOS,QUOD,QUOSE,ESCP

< 1.ESCP 
>


[*] (cst) CRLF : return a symbol containing Carriage return and line feed (0x0d,0x0a )

[*] (cst) BOM : return a symbol containing  Byte Order Mark  (0xFEFF ) for unicode text
Remark: 0xFEFF

[*] (fnc) CNSOUT : Output on the standard output device the concatenation of the slist of symbol

< 1.CNSOUT 
>


[*] (fnc) ERROUT : Output on the standard error device the concatenation of the slist of symbol

< 1.ERROUT 
>


[*] (fnc) ERRSHW : Return in a symbol system error output by the system

< 1.ERRSHW 
>


[*] (fnc) TMR : read the system  timer or the Thread timer or the Hres timer (FLOAT ms.us)

< 1.TMR 
>


[*] (fnc) CLOCK : Read system clock.

< 1.CLOCK 
>


[*] (fnc) LIBINF : Library information

< 1.LIBINF 
>


[*] (fnc) TRASH : delete system pointer and set to NULL the attribute

< 1.TRASH 
>


[*] (op 1) CMP : Compare 2 symbol. It applies a case and space sensitive comparison.

< 1.CMP 
>


[*] (fnc) CHATMSG : return the number of outstanding messages in chat

< 1.CHATMSG 
>


[*] (fnc) CHATPUT : Put a message in chat concatenating symbols

< 1.CHATPUT 
>


[*] (fnc) CHATSHW : Return chat message as a text of symb separated by CRLF
Remark: Not working in workbench mode

< 1.CHATSHW 
>


[*] (fnc) CHATGET : Get the first waiting message from chat

< 1.CHATGET 
>


[*] (fnc) CHATCLR : Remove all pending message from the chat

< 1.CHATCLR 
>


[*] (fnc) CNS : Show or Hide the console

< 1.CNS 
>


[*] (fnc) STDOUT : Output text on stdOut

< 1.STDOUT 
>


[*] (fnc) STDINP : Wait for a text line from stdInp

< 1.STDINP 
>


[*] (fnc) YIELD : Release the time slice to system in order to permit the execution of other processes.

[*] (fnc) SLEEP : Pause the current thread for a period
Remark: if period is FLT the function wait an amount of microsecond without  explicit release the Cpu

< 1.SLEEP 
>


[*] (fnc) WAITCND : Wait until the exit condition is satisfied

< 1.WAITCND 
>


[*] (fnc) SMF : operation on semaphore
Related: DOOR
Remark: There are 255 system semaphore (from  1 to 255 ) that can be used without creation

< 1.SMF - USE: Create – no parameter
>


< 2.SMF - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR|PTR||Any Pointer or SMF num (1-255)||
cmd|symb|£LCKS(lock 1 level);£LCKR (unlock 1 level);£RST (fully unlock);£TRY(try to lock);£OWN(return the thread owning);£WAIT(wait until is Locked);£WAITCNT(count of waiting Thr); £LINE(the line of the  lock)|Possible command||YES
PAR|NV||in ms the timeOut for CMD=£WAIT; 0= No TMO|0|YES

[RETURN|TYPE|VALUES|COMMENT]
Locks|NV|
Status|NV|
Thread|NV|

[EXAMPLE]
With parameters, to make an action on the semaphore. In case the caller asks for SMF lock with £LCKS, if the SMF is locked by someone else, the caller is paused until the semaphore is freed by the legitimate owner. If the SMF is locked by the caller, the level of the block is increased. To fully unlock a semaphore is required the owner to call £LCKR many time the owner have called the lock with £LCKS or to use £RST.

SMF();    >>>    SMF PTR

Semaphore held by a different caller:
SMF(pntSMF,£LCKS);
...wait so the owner unlocks the semaphore...
...after the unlock....
   >>>    1

Semaphore held by a different caller:
SMF(pntSMF,£TRY);    >>>    0

Semaphore is free:
SMF(pntSMF,£TRY);           >>>    1
…
SMF(pntSMF,£LCKS);           >>>    2 (level 2 lock)
…
SMF(pntSMF,£LCKR);          >>>    1 (unlock a level)
…
SMF(pntSMF,£LCKS);           >>>    2 (level 2 lock)
…
SMF(pntSMF,£LCKS);           >>>    3 (level 3 lock)
…
SMF(pntSMF,£RST);           >>>    0 (fully freed)


SMF(smfPtr, £OWN)              >> 0 if free, thread id of the locker, if locked
SMF(smfPtr, £LINE)       >> 0 if free, line where it was locked, if locked

SMF(smfPtr,£WAITCNT)    >> return the number of thread awaiting locked semaphore
>


[*] (fnc) DOOR : DOOR are synchronization object similar to SMF but can be lock and unLock by different Threads
Related: SMF
Remark: There are 255 system DOOR (from  1 to 255 )

< 1.DOOR - USE: TRY and  LCKS

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DOOR|NV||DOOR number  (1-255)||
cmd|symb|£TRY(try to lock);
£LCKS(lock 1 level);£LCKR(unlock 1 level);|Possible command||YES
KEY|symb||Key (required for LCKR)||YES

[RETURN|TYPE|VALUES|COMMENT]
key|symb|
Locks|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
With only DOOR number (without cmd) , number of locks are returned
With parameters, to make an action on the DOOR. While SMF are operated on thread basis, DOORs work on KEY basis. To Lock and Unlock, also in different threads,  you have to use the same key. If the DOOR is locked,  new requests with different KEY are queued until the DOOR is unlocked and served on First In basis. 
TRY and LCKS auto generate a unic key,  if the key is null;
>


[*] (fnc) PWKTASK : Execute  and manage PWK program as a task
Related: OSSHELL, OSSTART, OSEXEC ,OSCMD
Remark: The function waits the system to return the control

< 1.PWKTASK 
>


[*] (fnc) OSEXEC : Pass a command  to the operative system executor.
Related: OSSHELL,OSSTART, PWKEXEC, OSCMD
Remark: The function waits the system to return the control

< 1.OSEXEC 
>


[*] (fnc) OSCMD : Send a command to the system interpreter
Related: OSSHELL,OSSTART, PWKEXEC
Remark: The function waits the system to return the control

< 1.OSCMD 
>


[*] (fnc) OSSHELL : Execute an OS command.
Related: OSEXEC, OSSTART, PWKEXEC, OSCMD
Remark: With £WAIT the program open a doc and waits the closure of the page

< 1.OSSHELL 
>


[*] (fnc) OSSTART : Start e new process
Related: OSEXEC, OSSHELL, PWKEXEC, OSCMD

< 1.OSSTART 
>


[*] (fnc) CALC : Compute a formula

< 1.CALC 
>


[*] (fnc) LEN : Return the length of a symbol or a symbol allocated in buffer of NEW_LEN

< 1.LEN 
>


[*] (fnc) NSP : Purge a symbol from initial and final spaces.

< 1.NSP 
>


[*] (fnc) FST : Get Or Set the first character of a symbol.
Related: LST

< 1.FST 
>


[*] (fnc) LST : Get  or Set  the last character of a symbol
Related: FST

< 1.LST 
>


[*] (fnc) MID : Get or SET an internal part of a symbol

< 1.MID 
>


[*] (fnc) SPLT : Split a symbol, searching a separator
Related: TKNZ,TKNZOP,CSV, CSVTBL

< 1.SPLT - USE: Commento testo
>


[*] (fnc) TKNZ : Tokenize a symbol using a list of separators
Related: TKNZOP,SPLT,CSV, CSVTBL

< 1.TKNZ 
>


[*] (fnc) TKNZOP : Tokenize a symbol using a list of separator. Maintain the separator as element of the list.
Related: TKNZ,SPLT,CSV,

< 1.TKNZOP 
>


[*] (fnc) CSV : Broke a symbol using the default or the provided separator
Related: TKNZ,TKNZOP,SPLT,CSVTBL

< 1.CSV 
>


[*] (fnc) CSVTBL : Broke a symbol using separator for column and for rows preserving values content in block
Related: TKNZ,TKNZOP,SPLT, CSV
Remark: Return a TBL

< 1.CSVTBL 
>


[*] (fnc) SRCH : Search a symbol in an other.
Remark: Case sensitive

< 1.SRCH 
>


[*] (fnc) CAT : Concatenate a list of symbols

< 1.CAT 
>


[*] (fnc) MTCH : Search a symbol in an other with similar match too.
Related: CMP
Remark: The comparison is totally case insensitive and space insensitive.

< 1.MTCH 
>


[*] (fnc) LWR : Convert all Upper characters of  the symbol to lower
Related: UPR

< 1.LWR 
>


[*] (fnc) UPR : Convert all Lower characters of  the symbol to upper
Related: UPR

< 1.UPR 
>


[*] (fnc) RTF2TXT : Convert  RTF to standard  Text

< 1.RTF2TXT 
>


[*] (cst) PKGPTH : Return the Pakage path or NULL

< 1.PKGPTH 
>


[*] (cst) PWKPTH : Return the  path to POWER-KI directory

< 1.PWKPTH 
>


[*] (cst) EXECMODE : Return 1 if in exec mode , otherwise (WBK) return 0

[*] (fnc) ALIASPTH : Set or Get an alias for a ROOT item valid only inside the current thread
Remark: With only one parameter return how PWK apply the conversion to the symb

< 1.ALIASPTH 
>


[*] (fnc) TRIG : Define a trigger, linked to an EXO or MTDH.
Related: TRIGPAR(deprecated), TRIGSET (deprecated)
Remark: if EXO TRIGPAR names are different  use the = to establish  the relation)

< 1.TRIG 
>


[*] (fnc) TRIGSET : (deprecated) Define the relationship between trigger parameters and real variable of the linked function.
Related: TRIG, TRIGPAR
Remark: The TRIGpar code name depend of the function that use the TRIG

< 1.TRIGSET 
>


[*] (fnc) TRIGPAR : (deprecated) Set the trigger pars (comma separated enum) and define the relationship with the EXO pars
Related: TRIG, TRIGSET(deprecated)
Remark: if EXO params names are different  use the = to establish  the reation

< 1.TRIGPAR 
>


[*] (fnc) LIC : Get information from the License file

< 1.LIC 
>


[*] (fnc) THRINF : Return information about thread

< 1.THRINF 
>


[*] (fnc) THRSYM : Provides a Thread Local storage for Symbol

< 1.THRSYM 
>


[*] (fnc) THRPRI : Set Thread execution priority
Related: THRINF

< 1.THRPRI 
>


[*] (fnc) PTRTYP : Return the TYP of a PTR if  WITHLIB par is true  in the form  of TYP_LIB

< 1.PTRTYP 
>


[*] (fnc) PTRDUP : Increment the pointer reference count
Related: TRASH
Remark: the  pointer should be trashed one time more for each DUP but it is safe against deletions

< 1.PTRDUP 
>


[*] (fnc) PTRLIS : Return the LIS of existing PTR
Remark: The auxiliary element of each item contains the THREAD id, separed by "-"  from the line number where the pointer was created, separatede by “-”

< 1.PTRLIS 
>


[*] (fnc) THIS : Return the address ($) of the current code item of the main TREE

< 1.THIS 
>


[*] (fnc) BYADR : GET or SET the value of an attribute giving the ADDRE$
Remark: Use carrefully – Usable to keep trace of thread activity

< 1.BYADR - USE: GET
>


< 2.BYADR - USE: SET
>


[*] (fnc) SYMB_NRM : Normalize a symbol. Upper case and  remove all char having value les or equal to spaces .

< 1.SYMB_NRM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symb to normalize||
ASSPACE|symb||The first char is used as replacement for SPACE||YES
DISCARD|symb||The contained char in found in par are discarded||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[EXAMPLE]
a = “ Prova bella  “;
SYMB_NRM(a);    >>>    “PROVABELLA”
>


[*] (fnc) SYMB_HSH : Return the hash built summing each char without an offsett ( default 0x20)
Remark: If CRC a crc32 code is used, CKS=check sum

< 1.SYMB_HSH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symb to HASH||
OPTION|symb||Enum “MULTI, CASE,CKS”|CRC|YES
BASE|NV||Base|0x20 (space)|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
a = “casa mia“;
SYMB_HSH(a);          >>> 271
SYMB_HSH(a,£CASE);    >>> 495
SYMB_HSH(a,£MULTI);   >>> 152,119
>


[*] (fnc) SYMB_ENC : Return the symb encoded/escaped according to the required type/use (JSON)
Related: BUF_ENC

< 1.SYMB_ENC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symb to escape||
OPERATION|symb|£DO;£UNDO||DO|YES
TYPE|symb|£JSON;£B64;£URL||JSON|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
Symbol:
-Escaped for JSON like: " ' <CR> <LG> <TAB> <FF> 
-Encoded For B64 or URL
>


[*] (fnc) SYMB_BUFS : Manage long text as a collection of chunk (string)

< 1.SYMB_BUFS - USE: Create the pointer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 2.SYMB_BUFS - USE: Add a symbol

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFS|PTR||||
WHAT|symb|£ADD|||
SYMBOL|symb||Symbol to add||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 3.SYMB_BUFS - USE: Collapse the content in a symb

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFS|PTR||||
WHAT|symb|£COLLAPSE;£REVERSE(in reverse insertion order)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 4.SYMB_BUFS - USE: Reset BUFS content

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFS|PTR||||
WHAT|symb|£RESET|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 5.SYMB_BUFS - USE: SIZE

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFS|PTR||||
WHAT|symb|£SIZE|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) SYMB_INDX : Index of a symbol inside a comma separated list contained in a symbol

< 1.SYMB_INDX 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SEARCH|symb||Symbol to find (single word without spaces inside)||
IN|enum||enumeration of comma separated values||
SEP|NNV||Separator (one CHR)|,|YES

[RETURN|TYPE|VALUES|COMMENT]
POS|NV|
POS|NV|0

[EXAMPLE]
SYMB_INDX(“tre”,”uno,due tre,quattro”); >>>  2
SYMB_INDX(“tr”,”uno,due tre,quattro”);  >>>  0 (not found)
>


[*] (fnc) SYMB_SLCT : Giving a NV as index (1bsd) return the  symbol in the slist  or NULL

< 1.SYMB_SLCT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INDEX|NV||1bsd||
PARLIST|slist||list of symb||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|
RES|NV|NULL

[EXAMPLE]
SYMB_SLCT(3,”uno”,”due”,”tre”);    >>>    “tre”
>


[*] (fnc) SYMB_DCD : Decode a symbol contained in a enumeration with the counterpart at the same position in a list.
Remark: case insensitive comparison is applied

< 1.SYMB_DCD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symbol to decode (a single word without spaces inside)||
PARENUM|enum||Symbol containing a comma separated list of symbols||
PARLIST|slist||List of symbol||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|
RES|NV|NULL

[EXAMPLE]
SYMB_DCD(£uno, "uno,due,tre",£primo,£secondo,£terzo)    >>> "primo"
>


[*] (fnc) SYMB_RPLC : Replace (or remove) a symbol part
Remark: case insensitive comparison is applied

< 1.SYMB_RPLC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symbol to  Process||
SEARCHFOR|symb||Symbol to replace||
REPLACEWITH|symb||Replacement or NULL||
TIMES|NV||How many times|NULL|YES
STARTPOINT|NV||Starting from char (1bsd)||YES
CASE|NV|0(insensitive);1(Sensitivee)||1|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|
RES|NV|NULL

[EXAMPLE]
SYMB_RPLC(“?abc?d”, “?”,”1”)      >>> “1abc1d”
>


[*] (fnc) SYMB_BLKSEQ : Retrive inside a symbol the sequence of symbol  not separated or separated by space  provided as a slis
Related: SYMB_BLK

< 1.SYMB_BLKSEQ 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symb in witch search||
CASEtype|NV|0 (insensitive);1 (sensitive);|Type of comparison||
Sequence|slis||Sequence of symbol to search||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a = “ testo prima < br \> testo dopo “;
blk=SYMB_BLKSEQ(a,0,”<”,”br”,”\”,”>”);  

SYMB_BLK(blk,£BEF) = “ testo prima “
SYMB_BLK(blk,£AFT) = “ testo dopo “
SYMB_BLK(blk,£VAL) = “< br \>“

b = “ testo prima <br\> testo dopo “;
blk=SYMB_BLKSEQ(b,0,”<”,”br”,”\”,”>”);  

SYMB_BLK(blk,£BEF) = “ testo prima “
SYMB_BLK(blk,£AFT) = “ testo dopo “
SYMB_BLK(blk,£VAL) = “<br\>“
>


[*] (fnc) SYMB_BLKBLK : giving a starting and ending LIS of symbol retrieve inside a symb, the contained BLK
Related: SYMB_BLK

< 1.SYMB_BLKBLK 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||Symb in witch search||
CASEtype|NV|0(insensitive); 1(sensitive);|Type of comparison||
StartSequence|PTR||to LIS of  start Sequence||
EndSequence|PTR||to LIS of  end Sequence||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a = “ testo prima < testo contento > testo dopo “;
blk=SYMB_BLKBLK(a,0,LIS_NEW(“<”),LIS_NEW(“>”));  

SYMB_BLK(blk,£BEF) = “ testo prima “
SYMB_BLK(blk,£AFT) = “ testo dopo “
SYMB_BLK(blk,£VAL) = “< testo contento >“
SYMB_BLK(blk,£CNT) = “ testo contento “
>


[*] (fnc) SYMB_BLK : Get the element of a symb BLK
Related: SYMB_BLKSEQ

< 1.SYMB_BLK 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BLK|PTR||Pointer to a symb BLK||
SELECTOR|symb|£BEF;£AFT;£VAL;£CNT(content);£BEG(Begin position 1bsd);
£END(Begin position 1bsd);|if N.D. £CNT is assumed||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a = “ testo prima < br \> testo dopo “;
blk=SYMB_BLKSEQ(a,0,”<”,”br”,”\”,”>”);  

SYMB_BLK(blk,£BEF) = “ testo prima “
SYMB_BLK(blk,£AFT) = “ testo dopo “
SYMB_BLK(blk,£VAL) = “< br \>“

b = “ testo prima <br\> testo dopo “;
blk=SYMB_BLKSEQ(b,0,”<”,”br”,”\”,”>”);  

SYMB_BLK(blk,£BEF) = “ testo prima “
SYMB_BLK(blk,£AFT) = “ testo dopo “
SYMB_BLK(blk,£VAL) = “<br\>“
>


[*] (fnc) DB_OPN : Open a Data Base connection
Remark: delete with TRASH

< 1.DB_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TYPE|symb|£MYSQL;£SQLITE;£ODBC|||
IP|symb||IP address or host name||
USER|symb||User name||YES
PASSWORD|symb||User Password||YES
SCHEMA|symb||Default schema name||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|SYMB|NULL

[EXAMPLE]
DB_OPN(£MYSQL,"127.0.0.1",£root,£root)        >>> ptr to mySql comunication
DB_OPN(£sqLite,"local.db")                    >>> ptr to sqLite on file local.db
>


< 2.DB_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TYPE|symb|£ODBC|||
ODBC|symb||Id of the ODBC||
USER|symb||User name||YES
PASSWORD|symb||User Password||YES
SCHEMA|symb||Default schema name||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|SYMB|NULL

[EXAMPLE]
DB_OPN(£ODBC,£SQL,£root,£root)        >>> ptr to ODBC comunication

Note: ODBC must be 32bit version
>


[*] (fnc) DB_QRY : Make a query to DB
Related: DB_GET
Remark: If a result is returned it must be TRASH after use

< 1.DB_QRY 
>


[*] (fnc) DB_GET : Get data from a query result
Related: DB_QRY

< 1.DB_GET - USE: Rows and Columns num

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DBQRYRES|PTR||a PTR to DB query result||
ACTION|symb|£ROW(rows num);£COL(columns num);£RSLT(result)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[EXAMPLE]
lRes= DB_QRY(dbPtr."SELECT * FROM client"); !! TBL 20 columns, 5 rows

DB_GET(lRes,£ROW)       >>> 5 :  number of result rows
DB_GET(lRes,£COL)       >>> 20 : number of result columns
DB_GET(lRes,£RSLT)      >>> 5 :  affected rows (the listed rows in this case)
>


< 2.DB_GET - USE: Field content

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DBQRYRES|PTR||a PTR to DB query result||
ACTION|symb|£FLD|||
COL|symb||the num  1bsd or the name  of the field||
ROW|NV||the num 1bsd of the row||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
lRes= DB_QRY(dbPtr."SELECT * FROM client"); !! TBL 20 columns, 5 rows

DB_GET(lRes,£FLD,£name,1)       >>> "luca"
>


< 3.DB_GET - USE: A TBL containing the results

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DBQRYRES|PTR||a PTR to DB query result||
ACTION|symb|£TBL|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 4.DB_GET - USE: Row Lis

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DBQRYRES|PTR||a PTR to DB query result||
ACTION|symb|£ROWLIS|||
ROW|NV||the num 1bsd of the row||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
lRes= DB_QRY(dbPtr."SELECT * FROM client"); !! TBL 20 columns, 5 rows

DB_GET(lRes,£ROWLIS,1)       >>> List(1,"luca","Zampolon",28,5,1976,"Fresia"...)
>


< 5.DB_GET - USE: Columns Lis

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DBQRYRES|PTR||a PTR to DB query result||
ACTION|symb|£COLLIS|||
COL|symb||the num  1bsd or the name  of the column||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
lRes= DB_QRY(dbPtr."SELECT * FROM client"); !! TBL 20 columns, 5 rows

DB_GET(lRes,£COLLIS,£name)       >>> List("luca","pino","lino","arturo","tristano")
>


< 6.DB_GET - USE: Column name

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DBQRYRES|PTR||a PTR to DB query result||
ACTION|symb|£NAM|||
COL|NV||the num  1bsd field||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[EXAMPLE]
lRes= DB_QRY(dbPtr."SELECT * FROM client"); !! TBL 20 columns, 5 rows

DB_GET(lRes,£NAM,1)       >>> £ID
DB_GET(lRes,£NAM,2)       >>> £name
>


[*] (fnc) TREE_OPN : Create or open a tree
Remark: if no PAR is provided then the program tree Is opened.

< 1.TREE_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||£NEW for an empty tree or a path to an existing file containing a tree definition.||YES
STRICT|symb|0(NO);1(yes)|Strict XML flag|0|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[EXAMPLE]
TREE_OPN()        >>> actual program tree pointer. 
                      Pointer has to have destroied when you finished
TREE_OPN(£NEW)    >>> poiter to new independant tree

TREE_OPN("c:\PWK-PRG\test.pka") >>> pointer to pka
>


[*] (fnc) TREE_PARSE : Parse a unicode text

< 1.TREE_PARSE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|symb||A pointer to tree||
TEXT|symb||The text to parse||
STRICT|symb|0(NO);1(yes);2(HTML)|(0/1)=Strict XML flag(0/1). (2)=HTML|0|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|NV|ERR

[EXAMPLE]
txt="<xml....>"           >> text XML description of an item
TREE_PARSE(tree,txt)      >> add item, descripted by txt, in tree
>


[*] (fnc) TREE_SER : Serialize a tree or an item of a tree
Related: TREE_PARSE

< 1.TREE_SER 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|symb||A pointer to tree||
ITEM|symb||if N.D. all the tree is serialized||YES
FILE|symb||if N.D. the result return the serialization||YES
FLAG|enum|£ENC(encode entity);£TAB(output with tab);£HTML(html output);£KRP(crypto)|enc=encode entity; tab= output with tab; html=html output, krp=crypto|NULL|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
TREE_SER(tree)            
>> "<XML...>" : it returns a text with the serialization in xml of all the program 

TREE_SER(tree,itemPtr)
>> "<XML...>" : it returns a text with the serialization in xml of all the program
>


[*] (fnc) TREE_SAV : Save a tree in a file

< 1.TREE_SAV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|PTR||A pointer to a tree||
FILE|symb||the file name||
FLAG|enum|TAB(output with tab);£HTML(html output);£KRP(crypto)|tab= output with tab; html=html output, krp=crypto|NULL|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TREE_SAV(tree,"test.pka")        >> save tree in file test.pka
>


[*] (fnc) TREE_PTH : Retrieve a TREE_ITM address  giving the tree path
Remark: if PATH is NULL or \ the root item is returned

< 1.TREE_PTH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|PTR||A pointer to a tree||
PATH|symb||the tree path||
StartAddress|NV||item address from witch start||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
tree=TREE_OPN();            >> open the tree of the current program 
TREE_PTH(tree,"\")          >> pointer to the PWK item in the program 
TREE_PTH(tree,"\Main")      >> pointer to the \Main item in the program
>


[*] (fnc) TREE_ITM : Tree Item manipulation
Related: TREE_SRC

< 1.TREE_ITM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|PTR||A pointer to a tree||
ITM|symb||The Item name or address or £NEW or £NEWINROOT||
WHAT|symb|£VAL(Value);£PRV(previous);£NXT(next);£UPR(The Upper Item); £DUP(duplicate);£DEL(delete);
£ULK(UnLinl);
£PTH(return the full item Path); £ITM(ItemName);£PFX(prefix);£LBL(label);£TYP(type);£XIT(xtype);£SUB(subLis);£ATT(attLis);£ATY(Attribute Type);
£IDX(the Index of ITM);
£PTR(pointer of item);
£ADD( add $ITM in val at sub);
£ADDB(add $ITM in val BEFORE); £ADDA(add $ITM in val AFTER)|||
VAL|symb||if ITM=£NEW or  WHAT=£XIT(set) then VAL should be one of:  £ELEM, £ATTR, £TEXT, £XCMD, £CDTA, £DTDE, £CMNT||yes
AttVal|Symb||||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
tree=TREE_OPN();               >> pointer to current program 
itm=TREE_PTH(tree,"\");        >> pointer to first item in tree (\pwk)
itm=TREE_PTH(tree,"\pwk");     >> equivalent to previous code line

In usual pka, pwk contains items (VAR) Editor and Executor

sItm= TREE_ITM(tree,itm,£sub)  >> pointer to first item in pwk : Editor
sItm= TREE_ITM(tree,sItm,£nxt) >> p. to next object in the space of Editor : Executor
TREE_ITM(tree,sItm,£TYP)       >> VAR : the type of Executor


If the attributes are missing from an item and you want to add them:
attP=TREE_ITM(tree,£NEW,£XIT,£ATTR);
TREE_ITM(tree,attP,£ITM,"varDbg");
TREE_ITM(tree,attP,£LBL,"varDbg");
TREE_ITM(tree,attP,£VAL,"100");

TREE_ITM(tree,dstItm,£ATT,attP);

DELETION:

xi=TREE_ITM(TREE,xi,£DEL); !! Delete from  the TREE;

xi=TREE_ITM(tree,itm,£ULK); !!Unlink extract the itm from the tree;
xi=TREE_ITM(NULL,xi,£DEL); !! Delete the item without the TRRE only if Unlinked;
>


[*] (fnc) TREE_SRC : Search inside a tree
Related: TREE_ITM

< 1.TREE_SRC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|PTR||A pointer to a tree||
ITM|symb||The Item name or address||
WHERE|symb|£PRV(previous);£NXT(next);£UPR(The Upper Item);£SUB(subLis);£ATT(attLis);|||
WHAT|symb|£VAL(Value);£ITM(ItemName);£LBL(label);£TYP(type);£XIT(xtype);£ATY(Attribute Type);
£IDX(the Index of ITM);
£PTR(pointer of item)|||
VAL|symb||Value to compare||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) TREE_TRV : Traverse a document starting from an ITEM
Related: TREE_ITM

< 1.TREE_TRV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TREE|PTR||A pointer to a tree||
ITEM|NV||The Item address||YES
FATHER|NV|;|The Item address- limit the search below this item||YES
ATTRIBUTE|NV|0(NO);1(YES)|Include attributer||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
With only the tree PTR return the root item;

°xi=TREE_TRV(°tre);
°xn=TREE_TRV(°tre,°xi);
>


[*] (fnc) DOC_DOC : Create a Doc PTR and open it OR open a doc in a window OR print
Remark: With £WAIT  the document is open in a separate window. The application stops until this windows is open.

< 1.DOC_DOC - USE: Create a pointer to doc

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TYPE|symb|£OO(OpenOffice);£DEF(Default)||£DEF|
DOCname|symb||Document name||YES
ACTION|symb|£SHOW(Open in a window);
£PRINT;£WAIT(Open and wait for closure);£CREATE|With £CREATE (or N.D.)and DOCname defined, the doc is opened.|£CREATE|YES

[RETURN|TYPE|VALUES|COMMENT]
DOCptr|PTR|
RES|symb|NULL
RES|symb|NULL

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
docPtr=DOC_DOC(£OO,"text.odt")     >> open "text.odt" for read or modification
>


[*] (fnc) DOC_TPL : Create a document from a template
Remark: The name of destination document (without a path the document is stored in \windows\temp)

< 1.DOC_TPL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SourceDoc|symb||The name of the source document||
DestDoc|symb||The name of destination document (without a path the document is stored in C:\PWK-TMP)||
TemplateDir|symb||The template dir  (for source)||YES

[RETURN|TYPE|VALUES|COMMENT]
CreateDoc|symb|

[EXAMPLE]
DOC_TPL("template.odt", "c:\report\rep01.odt", PKGPTH) >>  "c:\report\rep01.odt"

This command generates file "c:\report\rep01.odt" as copy of the template file "template.odt" contained in the package.
>


[*] (fnc) DOC_OPN : Open a DOC
Related: DOC_DOC
Remark: Without the DOCNAME return the open status. If DOCNAME defined the old document is closed and the new one is opened.

< 1.DOC_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DOCptr|PTR||Ptr to doc||
DOCNAME|symb||New doc name||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
RES|NV|0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) DOC_CLS : Close a DOC
Related: DOC_SAV

< 1.DOC_CLS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DOCptr|PTR||PTR to doc||

[RETURN|TYPE|VALUES|COMMENT]
>


[*] (fnc) DOC_TBL : Retrieve a table inside DOC

< 1.DOC_TBL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DOCptr|PTR||PTR to DOC||
TABLE_NAME|symb||Table Name||YES

[RETURN|TYPE|VALUES|COMMENT]
TABLEptr|PTR|
TABLEall|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|NULL|

[EXAMPLE]
tblPtr=DOC_TBL(docPtr,"Table1")
>> docPtr is a pointer to a ODT text document, with a table named "Tabled1". You can name a table, entering in the property or simply write the name in the first cell of the table (high left),

The same command creates also the pointer to a sheet of a ODS datasheet.
>


[*] (fnc) DOC_TBLDUP : Duplicate a table and  insert before or after a table
Remark: if n.d. the REF_TABLE the duplicated table is used as reference for insertion

< 1.DOC_TBLDUP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TABLEptr|PTR||PTR to Table to duplicare||
NAME|symb||Table Name||YES
LINES|NV||Nuber of line between|0|YES
DIRECTION|symb|£AFTER;£BEFORE||£AFTER|YES
REF_TABLEptr|PTR||PTR to TABLE for insertion||YES

[RETURN|TYPE|VALUES|COMMENT]
TABLEptr|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|NULL|

[EXAMPLE]
!!! dstDos is a valid doc file, with a t_init and a t_a tables ;

initDT=DOC_TBL(dstDoc,"t_init");
aDT=DOC_TBL(dstDoc,"t_a");
!!! Insert a new t_a table after t_init ;
DOC_TBLDUP(aDT,"t_a_1",2,£AFTER,aDT);

DOC_SAV(dstDoc);
DOC_CLS(dstDoc);
>


[*] (fnc) DOC_TBLRMV : Remove a Table from the doc and also TRASH the PTR
Related: DOC_TBL, DOC_TBLDUP
Remark: i

< 1.DOC_TBLRMV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TABLEptr|PTR||PTR to Table to duplicare||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|NULL|

[EXAMPLE]
!!! dstDos is a valid doc file, with a t_a table ;

aDT=DOC_TBL(dstDoc,"t_a");
DOC_TBLRMV(aDT);

DOC_SAV(dstDoc);
DOC_CLS(dstDoc);
>


[*] (fnc) DOC_UF : Set or Get User field
Remark: NOTE: Any "line break" in the texts are transformed by the combination of characters CR [carriage return, ascii 0xC] + LN [line feed, ascii 0xA] to LF only, which in cases such as displaying in textbox can cause problems, since you can see all the text on one line.

< 1.DOC_UF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DOCptr|PTR||Pointer to DOC||
UFName|symb||User Field Name||
VALUE|symb||User Filed Name||YES

[RETURN|TYPE|VALUES|COMMENT]
VALUE|symb|

[EXAMPLE]
docPtr is pointer to a text ODT document that contains a user field "clientId"
DOC_UF(docPTr,£clientId,"Gerolamo")           >> set value of user field "clientId" to "Gerolamo"
>


< DOC_TVL - USE: fnc
< 1.DOC_TVL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TABLEptr|PTR||PTR to Table||
COL|symb||Column  number (1bsd) or identifier in Letter notation||
ROW|NV||Row 1bsd||
VALtype|symb|£STRING;£FLOAT;£BLOCK(in ODF)|£STRING;£FLOAT;£BLOCK||YES
VALUE|symb||value to set||YES
HEADER|symb|£TRUE;£FALSE|if TRUE col and row refer to header|FALSE|YES

[RETURN|TYPE|VALUES|COMMENT]
VALUE|symb|

[EXAMPLE]
tblPtr is a poiter to a sheet of a datasheet file.
DOC_TVL(tblPTr,£U,9,"STRING",t1);
>> Write the content of the attrib t1 in the cell U9 of datasheet as a string. VALtype "STRING" is the best working in all the situation.
>


[*] (fnc) DOC_TINF : Retrieve information about the table
Related: DOC_TVL

< 1.DOC_TINF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TABLEptr|PTR||PTR to Table||
WHAT|symb|£COL(Col num);£ROW(Total Row num);£ROWDAT(Row data num)|||

[RETURN|TYPE|VALUES|COMMENT]
VALUE|symb|

[EXAMPLE]
DOC_TINF(tbl,£ROW)      >> 11, 1 header + 10 data row
DOC_TINF(tbl,£ROWDAT)   >> 10
>


[*] (fnc) DOC_SAV : Save the modification applied to the document, on disk

< 1.DOC_SAV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DOCptr|PTR||PTR to Doc||

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
DOC_SAV(docP)       >>> save document opened with docP pointer
>


[*] (fnc) BUF_NEW : Create a Buffer

< 1.BUF_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NumElem|NV||number of element of TYP||
TYP|symb|£U8;£I8;£C8;£U16;£I16;£C16;£U32;£I32;£F32;£U64;£I64;£F64|||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a=BUF_NEW(15,£U8);       
   >>>    a points to a 15 bytes buffer, with 15 unsigned char values.

b=BUF_NEW(10,£F32);
   >>>    b points to a 40 bytes buffer, with 10 float values.
>


[*] (fnc) BUF_SMF : operation on TBL semaphore
Related: DOOR, SMF
Remark: DEPRECATED use SMF

< 1.BUF_SMF - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to LIS|PTR||PTR to BUF||
cmd|symb|£LCKS(lock 1 level);£LCKR (unlock 1 level);£RST (fully unlock);£TRY(try to lock);£OWN(return the thread owning);£WAIT(wait until is Locked) ;£WAITCNT(count of waiting Thr)|Possible command||YES

[RETURN|TYPE|VALUES|COMMENT]
Locks|NV|
Status|NV|
Thread|NV|

[EXAMPLE]
see and use SMF
>


[*] (fnc) BUF_BUF : Create  view BUF inside another BUF

< 1.BUF_BUF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
MAINBUF|PTR||PTR to main BUF||
STARTIDX|NV||Start index (in byte, 1bsd) inside MAINBUF||
TYPE|symb|£U8;£I8;£C8;£U16;£I16;£C16;£X24;£U32;£I32;£F32;£U64;£I64;£F64|if not declared will be the same of MAINBUF||yes
SIZE|NV||in byte, if not declared will be the trailing size of MAINBUF starting from STARTIDX||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a=BUF_NEW(10,£U32);
b=BUF_BUF(a,1,£U8);
“b” is able to access “a” BUF data as unsigned char.
>


[*] (fnc) BUF_VAL : Get or set a BUF element

< 1.BUF_VAL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||PTR to  BUF||
INDEX|NV||1bsd; if TYPE is NULL this is in TYPE unit else is in BYTE||
VALUE|symb||if defined is SET||yes
TYPE|symb|£U8;£I8;£C8;£U16;£I16;£C16;£X24;£U32;£I32;£F32;£U64;£I64;£F64|if not declared BUF type will be used||yes
SWAP|symb|£BYTE;£WORD;£DWORD(Swap Dword);£XDWORD(Exchange WORD);£QWORD|Swap to apply||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
BUF a contains  (192,168,0, 1) as £U32

b=BUF_BUF(a,1,£U8);
BUF_VAL(a,1,IP_address);
part1_of_ip = BUF_VAL(b,4);          >>>    192
part2_of_ip = BUF_VAL(b,3);          >>>    168
part3_of_ip = BUF_VAL(b,2);          >>>      0
part4_of_ip = BUF_VAL(b,1);          >>>      1

Alternate method:
part1_of_ip = BUF_VAL(a,4,NULL,£U8);          >>>    192
part2_of_ip = BUF_VAL(a,3,NULL,£U8);          >>>    168
part3_of_ip = BUF_VAL(a,2,NULL,£U8);          >>>      0
part4_of_ip = BUF_VAL(a,1,NULL,£U8);          >>>      1

SWAP:
BYTE   ab       ba (4bit)
WORD   AB       BA (8bit)
DWORD  ABCD     DCBA
XDWORD ABCD     CDAB
QWORD  ABCDEFGH GHEFCDAB
>


[*] (fnc) BUF_MTX : Multi dimensional Matrix of value from created or existing buffer
Remark: Using the MTX if not all index are specified returns the index address (__ADDR_)

< 1.BUF_MTX - USE: Creation of a matrix wit associated Buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WHT|symb|£NEW|||
ELM_TYP_SIZ|symb|£U8;£I8;£C8;£U16;£I16;£C16;£X24;£U32;£I32;£F32;£U64;£I64;£F64|For string use the number of char with U as postfix for Unicode (default is ASCII)||
VOID|symb|NULL||NULL|YES
DIM_x|slis||of number of elements for dimension||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
m=BUF_MTX(£NEW, £U16,NULL, 5, 6, 7); //three dimension matrix of U16 values;
BUF_MTX(m, NULL, 25, 1, 2, 3); !!Set the value at[1][2][3]=25:
r=BUF_MTX(m, NULL, NULL, 1, 2, 3); !!Get the value; 

mu=BUF_MTX(£NEW, £10U, 5, 6, 7); //Matrix of unicode string of 10 char; 
ma=BUF_MTX(£NEW, 10, 5, 6, 7); //Matrix of ASCII string of 10 char;
>


< 2.BUF_MTX - USE: Creation of a matrix From an existing  Buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFF|PTR||PTR of an existing buffer||
ELM_TYP_SIZ|symb|£U8;£I8;£C8;£U16;£I16;£C16;£X24;£U32;£I32;£F32;£U64;£I64;£F64|For string use the number of char with U as postfix for Unicode (default is ASCII)||
VOID|symb|NULL||NULL|YES
DIM_x|slis||of number of elements for dimension||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=BUF_NEW(210,£U16);
m=BUF_MTX(buf, £U16,NULL, 5, 6, 7); //three dimension matrix of U16 values;
BUF_MTX(m,NULL; 25, 1, 2, 3); !!Set the value at[1][2][3]=25:
r=BUF_MTX(m, NULL, NULL, 1, 2, 3); !!Get the value;
>


< 3.BUF_MTX - USE: Get or Set vsalues

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
MTX|PTR||MTX PTR||
ELM_TYP_SIZ|symb|£U8;£I8;£C8;£U16;£I16;£C16;£X24;£U32;£I32;£F32;£U64;£I64;£F64|If N.D. is used the data used in the creation|NULL|YES
VALUE|symb||if NULL read, else a value to set is assumed, if the keyword _ADDR_ is used  as value the element index is returned|NULL|YES
IDX_x|slis||dimension index||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|
IDX|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=BUF_NEW(210,£U16);
m=BUF_MTX(buf, £U16,NULL, 5, 6, 7); //three dimension matrix of U16 values;
BUF_MTX(m,NULL, 25, 1, 2, 3); !!Set the value at[1][2][3]=25:
r=BUF_MTX(m, NULL, NULL, 1, 2, 3); !!Get the value; 

idx=BUF_MTX(m, £_ADDR_,NULL, 1, 2, 3); !!return the index address of element; 

r=BUF_MTX(m, £U32, NULL, 1, 2); !!return the value of the first element of the 3rd dimension as U32;
>


[*] (fnc) BUF_CPY : Copy a BUF into another
Remark: if Offsets are outside ranges the function does nothing.

< 1.BUF_CPY 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFDST|PTR||Destination BUF||
BUFSRC|PTR||Source BUF||
SIZE|NV||Number of byte to copy; if not defined the lower of dst,src size is used; the same if size if  higher then src or dst size||yes
OFFDST|NV||Offset inside destination||yes
OFFSRC|NV||Offset inside source||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
BUF_CPY(bufDst,bufSrc,20,101,1);  
!! Copy first 20 byte of bufSrc at byte 100 of destination
>


[*] (fnc) BUF_CAT : Concatenate two buffer in a new one
Remark: The type of the new BUF will be that of BUFone

< 1.BUF_CAT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFone|PTR||First BUF||
BUFtwo|PTR||Second BUF||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf1=BUF_NEW(100,£U8);
buf2=BUF_NEW(50,£U8);
buf3=BUF_CAT(buf1,buf2);
BUF_INFO(buf3,£SIZ)     >>> 150, buf3 contains the content of buf1 + buf2
>


[*] (fnc) BUF_CMP : Compare for equality two BUF
Remark: If the offset are out of the related buffer size, the function does nothing.

< 1.BUF_CMP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUFone|PTR||Source BUF||
BUFtwo|PTR||Destination BUF||
SIZ|NV||Number of byte to compare; if not defined the lower of one,two size is used; the same if size if  higher then one or two size||yes
OFFone|NV||1bsd; offset inside BUF one||yes
OFFtwo|NV||1bsd; offset inside BUF two||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
RES|NV|0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
BUF_COM(buf1,buf2,20,1,101)     
!!! Compare first 20 byte of buffer 1 with 20 byte at 100 of buffer 2
>


[*] (fnc) BUF_RST : Reset a BUF filling with £U8 value

< 1.BUF_RST 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||Source BUF||
VALUE|NV||Value for fill|0|yes
SIZ|NV||If N.D. BUF size is used||yes
OFF|NV||The Offset (1 based)|1|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[EXAMPLE]
BUF_RST(buf)            !!! Fill buf with 0
BUF_RST(buf,32,20,101)  !!! Fill 20 byte at offset 100(0 bsd) with space
>


[*] (fnc) BUF_ENC : Encode the content of  the buffer

< 1.BUF_ENC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||PTR to BUF||
FROM|symb|£A;£U;£UTF;£B64|Source encoding||
TO|symb|£A;£U;£UTF;£B64|Target encoding||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
BUF_RST(buf)            !!! Fill buf with 0
BUF_RST(buf,32,20,101)  !!! Fill 20 byte at offset 100(0 bsd) with space
>


[*] (fnc) BUF_INFO : Return information about a BUF

< 1.BUF_INFO - USE: about a BUF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||to BUF||
SELECTOR|symb|£SIZ(Size in U8);£TYP(declared type);£NUM(number of element of BUF type)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a=BUF_NEW(10,£U32);
BUF_INFO(a,£SIZ);           >>>    40
BUF_INFO(a,£TYP);           >>>    £U32
BUF_INFO(a,£NUM);           >>>    10
>


< 2.BUF_INFO - USE: about a BUF MTX

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||to BUF MTX||
SELECTOR|symb|£NDIM(Number of dimension);£TYP(data Type);£TOT(number of elements);£ESZ(Element size);£PTRBUF(PTR to inner buffer);SIZ(Total size in byte)|if SELECT is a NV (1bsd) the size of the dimension, in number of elements is returned, (1=COL, 2=ROW)||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
a=BUF_NEW(10,£U32);
BUF_INFO(a,£SIZ);           >>>    40
BUF_INFO(a,£TYP);           >>>    £U32
BUF_INFO(a,£NUM);           >>>    10
>


[*] (fnc) BUF_SYMB : Get/set a symbol into/from a BUF
Remark: BUF is assumed to contains £C8 while VALUE contains £C16 so ASCII<-->Unicode conversion is performed

< 1.BUF_SYMB 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||to BUF||
OFF|NV||1bsd;|1|yes
SIZE|NV||size in U8,if N.D. is from OFF to end||yes
VALUE|symb||Set BUF with VALUE||yes
ENCODING|symb|£A(ASCII);£U(UNICODE);£UTF(UTF8)|Encoding of symbol|£A|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
BUF_SYMB(buf,1,15,NULL,£A)   >> read an ascii string from buf at position 0

Note: OFF 0 works as OFF 1
Note: if SIZE > LEN(VALUE), it fills the remaining (SIZE-LEN(VALUE)) ending symb positions with 0
>


[*] (fnc) BUF_AUDIO : Convert a BUF audio format in a new BUF
Related: GUI_AUDIO

< 1.BUF_AUDIO 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||PTR to main BUF||
FORMAT|symb|£RAW2WAV; £WAV2RAW||RAW2WAV|yes
CHN|NV||Channel|1|yes
SPS|NV||Sample per Second|44100|yes
BPS|NV||Bit Per Sample|16|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) BUF_CPRS : Compress and Uncompress a buffer in a new one

< 1.BUF_CPRS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
BUF|PTR||PTR to main BUF||
OP|symb|£DO(Compress); £UN(Uncompress)|Start index (in byte, 1bsd) inside MAINBUF||
SIZE|NV||For UN expected  uncompressed size||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
ERR coud be a NV:
Z_OK            0
Z_STREAM_END    1
Z_NEED_DICT     2
Z_ERRNO        (-1)
Z_STREAM_ERROR (-2)
Z_DATA_ERROR   (-3)
Z_MEM_ERROR    (-4)
Z_BUF_ERROR    (-5)
Z_VERSION_ERROR (-6)
>


[*] (fnc) FS_FIND : Search within a directory for files. Wildcard are allowed.
Remark: if file name does not contains absolute path current directory is assumed

< 1.FS_FIND 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILEname|symb||file name to search ; if N.D. “*.*” is used||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
lis=FS_FIND("c:\tmp\*.txt") 
>> generate lis, a list pointer, with first element ".", and second "..".
The filename in list are without path.
>


[*] (fnc) FS_INFO : Return file or directory info.
Remark: Time is in second since 00:00 of January the 1st 1970.

< 1.FS_INFO 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NAME|symb||file or directory name||
SELECTOR|symb|£SIZ(Size in U8);£TC(creation time);£TA(last access time);£TW(last write time);£TYP(return £DIR or £FIL);£ATT(OS attribute);£TWHTTP(time write HTTP ts)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FS_INFO("temp.txt",£SIZ)    
>> size of temp.txt. 
0 : file exists but it is empty
NULL : file doesn't exists
>


[*] (fnc) FS_LOG : Save a Text in a file
Remark: if file name does not contains the path current directory is assumed

< 1.FS_LOG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILEname|symb||||
TEXT|symb||Text to save||
MODE|symb|£NEW(file is created);£ADD(text is added to the end)||£NEW|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
r=FS_LOG("myLog.txt","this is a test"); !!new file or overwrite existing;
r=FS_LOG("myLog.txt","this is a test", £ADD); !!the text is added to the end;

A CRLF is inserted Before each inserction.
>


[*] (fnc) FS_DCWD : Set or get  Current Working Directory

< 1.FS_DCWD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DIRECTORY|symb||(set) new directory||opt

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FS_DCWD       >> "P:\PWK-PRG\Apps\PWK\PWK-ISP " example of working directory
>


[*] (fnc) FS_DMK : Directory: Create

< 1.FS_DMK 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DIRECTORY|symb||directory name||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[EXAMPLE]
FS_DMK("C:\PWK-PRG\LOG")   
  >>> 1 success (create LOG but C:\PWK-PRG has to exist)

FS_DMK("C:\PWK-PRG\A\B")   
  >>> 0, it doesn't work if C:\PWK-PRG\A doesn't exist
>


[*] (fnc) FS_DRM : Directory: remove (also sub directory)

< 1.FS_DRM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DIRECTORY|symb||Directory name||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[EXAMPLE]
FS_DMK("C:\PWK-PRG\A");         >>> C:\PWK-PRG has to exist
FS_DMK("C:\PWK-PRG\A\B");
FS_DMK("C:\PWK-PRG\A\B\C");

FS_DMK("C:\PWK-PRG\A");         >>> 1, delete A, A\B and A\B\C
>


[*] (fnc) FS_DRN : Directory: rename

< 1.FS_DRN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OLDname|symb||Old directory name||
NEWname|symb||New directory name||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[EXAMPLE]
FS_DRN("C:\PWK-PRG\A","C:\PWK-PRG\B")   !!! Rename A in B
>


[*] (fnc) FS_FDEL : File: delete

< 1.FS_FDEL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb||File name to delete||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
>


[*] (fnc) FS_FCPY : File: copy

< 1.FS_FCPY 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILEsrc|symb||Source file name||
FILEdst|symb||Destination file name||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
>


[*] (fnc) FS_FREN : File: rename

< 1.FS_FREN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OLDFILENAME|symb||||
NEWFILENAME|symb||||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) FS_FOPN : File: open unbuffered
Related: FS_FOPNB

< 1.FS_FOPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb||File name||
OPENFLAG|enum|"APPEND, BINARY, CREAT, RDONLY, WRONLY, RDWR, TEXT, TRUNC, EXCL"(all possible flags);
£APPEND(open file for append);£BINARY(open binary file);£CREAT (create file);£RDONLY (read only);£WRONLY (write only);£RDWR(read and write);£TEXT(text file);£TRUNC;£EXCL(exclusive access)|||
CREATEMODE|enum|£;£READ;£WRITE;"READ,WRITE"|||yes
LOCK|symb|£LCKNO;£LCKRW;£LCKR;£LCKW||£LCKNO|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
Prefer BINARY mode and RDWR, for maximal compatibility.
>


[*] (fnc) FS_FOPNB : File: open buffered
Related: FS_FOPNB

< 1.FS_FOPNB 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb||File name||
MODE|enum|£r(read must exists);£w(write if exist its contents are destroyed);£a(append);"r+"(read and write must exists); "w+"(read and write contents are destroyed);"a+"(reading and appending created in not exists);£wb(binary);"wb+"(binary)|Add b=binary t=text||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
This management is faster, but the writes may not be instantaneous because they are buffered
>


[*] (fnc) FS_FINP : File: BUF input

< 1.FS_FINP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE|PTR||Pointer to an open file||
SIZE|NV||the number of U8 to read||
FILEPOS|symb||NV position in byte (0bsd) or £CUR (current).||
BUF|PTR||Pointer to destination buffer||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FS_FINP(filPtr,100,0,BUF)  >> 100 : read 100 byte from file to buffer
                           >> NULL : probably problem with file pointer
>


[*] (fnc) FS_FOUT : File: BUF Output

< 1.FS_FOUT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE|PTR||Pointer to an open file||
BUF|PTR||Pointer to source buffer||
FILEPOS|symb||NV position in byte (0bsd) or £CUR (current).||yes
SIZE|NV||the number of U8 to write||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FS_FOUT(filPtr,BUF,0,20)   >> 20 : write 20 byte from buffer to file 
                           >> NULL : probably problem with file pointer
>


[*] (fnc) FS_FWRS : File: write symbol

< 1.FS_FWRS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE|PTR||Pointer to an open file||
FILEPOS|symb||NV position in byte (0bsd) or £CUR (current).||
ENCODE|symb|£A(encoding ASCII);£U(encoding UNICODE)|Encoding of VALUES||
VALUES|slis||Symbols to concatenate in a single write||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FS_FWRS(filPtr,0,£A,"Prova prova");   >>> 11 : write string in file
                                      >>> NULL : probably a problem with file                     
                                                 pointer
>


[*] (fnc) FS_FRDS : File: read symbol

< 1.FS_FRDS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE|PTR||Pointer to an open file||
FILEPOS|symb||NV position in byte (0bsd) or £CUR (current).||
ENCODE|symb|£A(encoding ASCII);£U (encoding UNICODE)|Encoding of VALUES||
TERM_SIZE|symb||if NV TERM contains the size (U8), else is the line terminator||
FLAG|symb|£ZEROTOSP|Only for SIZE enc £A or £U, zero are replaced by spaces||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FS_FWRS(filPtr,0,£A,"Provaccia!");
FS_FWRS(filPtr,0,£A,"Prova");       >>> 5 : write Prova + terminator 0

FS_FRDS(filPtr,0,£A,10)             >>> "Prova"
FS_FRDS(filPtr,0,£A,10,£ZEROTOSP)   >>> "Prova ccia!"
>


[*] (fnc) FS_FWRS_F : write a text  directly to file.
Related: FS_FRDS_F, FS_FWRS, FS_FRDS,
Remark: if file name does not contains the path current directory is assumed

< 1.FS_FWRS_F 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILEname|symb||||
TEXT_OR_PTR|symb||textto save  or PTR to BUF||
MODE|symb|£NEW(file is created);£ADD(text is added to the end)||£NEW|YES
CODING|symb|£U;£A;£UTF;|Only for TEXT|£U|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
r=FS_FWRS_F("myFile.txt","this is a test"); !!new file or overwrite existing;
r=FS_FWRS_F("myFile.txt","this is a test", £ADD); !!the text is added to the end;

A CRLF is inserted Before each insertion.
>


[*] (fnc) FS_FRDS_F : Read a text  directly from  file.
Related: FS_FWRS_F, FS_FWRS, FS_FRDS,
Remark: if file name does not contains the path current directory is assumed

< 1.FS_FRDS_F 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILEname|symb||||
CODING|symb|£U;£A;£UTF;£BUF||£A|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
r=FS_FRDS_F("myFile.txt");
>


[*] (fnc) FS_FPOS : File: Set or Get the read/write  current position into a FILE

< 1.FS_FPOS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE|PTR||Pointer to an open file||
FILEPOS|symb||(set) NV position in byte (0bsd) or £CUR (current).||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) SOK_NEW : Create a new SOK (socket)

< 1.SOK_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TYPE|symb|£UDP;£TCP|SOK type||
IA|symb||Local Internet Address.If N.D. assigned first network device address is used||yes
PORT|NV||Local Port Number (1-65535). if N.D. is taken from the free port pool.||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_NEW(£TCP)           >>> pointer, open a TCP socket

SOK_NEW(£TCP,0,6000);   >>> pointer, open a TCP socket on port 6000
>


[*] (fnc) SOK_LKO : Open a link
Remark: This function is used for TCP active connection and in UDP for enable receive

< 1.SOK_LKO 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||Pointer to a valid SOK||
LocPORT|NV||if 0 or NULL is assumed to be the same of SOK_NEW||yes
RmtAddres|symb||Remote IA or name  (opt for UDP)||yes
RmtPORT|NV||Remote port [1-65535] (opt for UDP)||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|>0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
sok= SOK_NEW(£TCP);
SOK_LKO(sok,NULL,"192.168.2.200",6000)    
>>> 1, open a TCP comunication with a remote server on port 6000
>>> 0, a problem occurred, manage it
>


[*] (fnc) SOK_LKC : Close a link
Remark: This function is for TCP connection

< 1.SOK_LKC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||Pointer to a valid SOK||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_LKC(sok)    >>> close socket
>


[*] (fnc) SOK_LKW : Wait for a link
Remark: if TRIG is defined this function return only if there is an error or the SOK is closed.
if SELECTOR=£THREAD a new TEMPORARY SOK is create to sustain the conversation with the connecting partner, in a new thread. This SOK is delete at the end of the TRIG. In this way many partner can be served.
if SELECTOR=£INPLACE the TRIG is executed as a simple call to an EXO. 
The TRIG is to set with this parameters:
1) SOK, where it's returned PTR to SOK
2) ADDRESS, where it's returned the address of incoming transmission
3) PORT, where it's returned the port of incoming transmission

< 1.SOK_LKW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
LocPORT|NV||if 0 or NULL is assumed to be the same of SOK_NEW|0|yes
RmtADDRESS|symb||listen only from this address. if N.D. or 0 from all;|NULL|yes
RmtPORT|symb||listen only from this port. if N.D. or 0 from all;|0|yes
TRIG|PTR||Trig to activate at connection|NULL|yes
SELECTOR|symb|£THREAD;£INPLACE|If TRIG is valid it is start in a new Thread or in the actual thread (only if TRIG is valid)|£INPLACE|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INPLACE VERSION :

SOK_LKW(sok,4000,"192.168.2.200",0,NULL,£INPLACE) 
>>> Awaiting something on port 4000 from a specific remote PC. 
The program stops on this line, awaiting for data.
When something arrives, the program proceed.


TRIGGERED VERSION :

!!! Define a trigger to manage the remote connections ;
trg=       TRIG("\NET\Trig");
TRIGSET(trg,"SOK","SOK");
TRIGSET(trg,"ADDRESS","ADDRESS");
TRIGSET(trg,"PORT","PORT");

!!! Link wait trigger version ;
!!! To leave this row, something external have to trash sok pointer ;
SOK_LKW(sok,0,0,0,trg,£THREAD);
>


[*] (fnc) SOK_RCV : Receive data into a BUF

< 1.SOK_RCV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
BUF|PTR||BUF to store received data||
REQDATASIZE|NV||if defined  the function wait until the data size is reached.||yes
TMO|NV||Time out in ms||yes
MODE|symb|NULL;£LINE|if £LINE wait for a CRLF (not returned in data)||yes
BUF_IDX|NV||start position in buffer for read values|1|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_RCV(sok,buf,100,10000)
>>> number of received bytes. The program stops on this line until it receives 100 bytes or 10 seconds pass. If the timeout expires, the bytes received up to that moment will be present in the buf (less than 100)
>


[*] (fnc) SOK_RCVPKT : Receive data into a new BUF

< 1.SOK_RCVPKT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
TMO|NV||Time out in ms||yes

[RETURN|TYPE|VALUES|COMMENT]
BUF|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) SOK_INQ : Inquire  to see if any data is arrived

< 1.SOK_INQ 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
TMO|NV||Time out in ms||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_INQ(sok,1000)
>>> NULL : connection closed
>>> 0 : no data received
>>> >0 : size of data received
>


[*] (fnc) SOK_ADR : Return the address of the last communication peer

< 1.SOK_ADR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_ADR(sok)      >>> "192.168.2.144"
>


[*] (fnc) SOK_POR : Return the port of the last communication peer

< 1.SOK_POR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_POR(sok)     >>> 50132, comunication port
>


[*] (fnc) SOK_STS : SOK Status

< 1.SOK_STS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|0
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_STS(sok)
>>> 0 : comunication closed
>>> 1 : comunication OK
>


[*] (fnc) SOK_SND : Send data on a SOK from a BUF
Related: RCVPKT

< 1.SOK_SND 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
BUF|PTR||To a valid BUF||
SIZE|NV||if N.D. BUF size is used||yes
RmtADDRESS|symb||Remote IA or Name, for TCP connection is unnecessary||yes
RmtPORT|NV||Remote Port  for TCP connection is unnecessary||yes
SNDTYPE|symb|NULL;£PKT|Use RCVPKT on the receive side||yes
BUF_IDX|NV||start position in buffer for read values|1|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_SND(sok,buf,100,NULL,NULL,£PKT)   >>> 100, sent bytes
>


[*] (fnc) SOK_WRS : Send symbol on a SOK

< 1.SOK_WRS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
DATA|symb||Symb to sent||
ENCODING|symb|£A(ASCII);£UTF;£U(U16);£PKT|Encoding|£PKT|yes
RmtADDRESS|symb||Remote IA or Name, for TCP connection is unnecessary||yes
RmtPORT|NV||Remote Port  for TCP connection is unnecessary||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
t1="pippo";
SOK_WRS(sok,t1,£A)    >>> 5, sent bytes
>


[*] (fnc) SOK_RDS : Receive a symbol on a SOK

< 1.SOK_RDS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||
ENCODING|symb|£A(ASCII);£UTF;£U(U16);£PKT(datasize and  mode are ignored)|Encoding|£PKT|yes
REQDATASIZE|NV||If defined the function will wait this data size ammount||yes
TMO|NV||Time out in ms||yes
MODE|symb|NULL;£LINE|if £LINE wait for a CRLF (not returned in data)||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_RDS(sok,£PKT,NULL,10000)
>>> read value
>>> NULL, sending error or timeout
>


[*] (fnc) SOK_INF : Get the dotted IP;PORT of the actual socket  or NULL (if not bind)

< 1.SOK_INF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SOK|PTR||To a valid SOK||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
SOK_INF(sok)     >>> "192.168.2.144;60123"
>


[*] (fnc) IEP_SRV : Create  an IEP SRV (server)

< 1.IEP_SRV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
LocADDRESS|sym||Local IA||
LocPORT|NV||Local port (usually 1800,502 modbus)||
TYPE|sym|£IEP;£MODBUS||£IEP|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
iep=IEP_SRV("192.168.2.144",1800,£IEP);
>


[*] (fnc) IEP_SRVADD : Create the reference to a memory area (BUF) in a IEP SRV instance.
Remark: Trash IEP DB pointer before trash the IEP SRV Ptr.

< 1.IEP_SRVADD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEPSRV|PTR||Valid PTR to IEP SRV||
UNIT|NV||The unit number (for remote reference)||
SUB|NV||The sub unit number (for remote reference – not used if MODBUS )||
BUF|PTR||Valid pointer to a BUF||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf1=BUF_NEW(1000,£U8);
IEP_SRVADD(iep,100,0,buf1);
>


[*] (fnc) IEP_SRVCMD : Start and Stop IEP_SRV

< 1.IEP_SRVCMD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEPSRV|PTR||Valid PTR to IEP SRV||
COMMAND|symb|£START;£STOP|||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
IEP_SRVCMD(iep,£START);
>


[*] (fnc) IEP_CLI : Create a IEP CLI (client)  and connect it to  a  IEP SRV DB.

< 1.IEP_CLI 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SRVADDRESS|symb||IA of IEP SRV||
SRVPORT|NV||IEP SRV PORT||
CONTYPE|symb|£IEP(XPOLYPLUS,Siemens);£NTLK(Net-Link);£MBUS(modBus)|||
CLIADDRESS|symb||Local IA||yes
CLIPORT|NV||Local Port||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
iep=IEP_CLI("192.168.2.144",1800,£IEP);
>


[*] (fnc) IEP_CLICON : Set  IEP CLI connection parameters .

< 1.IEP_CLICON 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEP_CLI|PTR||Pointer to a valid IEP CLI||
UNIT|NV||Unit number of IEP SRV DB||
SUB|NV||Sub Unit number of IEP SRV DB||
SWAP|enum|NULL;"HEAD,WORD";"HEAD,DWORD";"WORD";"DWORD"|Swap of head and data.||yes
MTU|NV||Maximum Transfer Unit||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
IEP_CLICON(iep,100,0);
MODBUS: UNIT is the 485 address of a unit; swap HEAD
>


[*] (fnc) IEP_CLIDAT : Set  IEP CLI data  parameters .

< 1.IEP_CLIDAT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEP_CLI|PTR||Pointer to a valid IEP CLI||
PAGE|NV||Page Number (Siemens/NTLK  DB)||
OBJ|NV|NULL;131(Siemens merker);132(Siemens DB);49(NTLK db);51(NTLK merker);52(NTLK I/O);53 (NTLK Counters);54(NTLK timers);3(ModBus Holding Register);4(Modbus Input Register)|MODBUS Input Register can only be read||
OBJsize|NV||Size in byte of object||
OBJnum|NV||Number of object||
OFFSET|NV||(0bsb) offset in IEP SRV DB||
OFFSETunit|symb|£BYTE;£WORD;£DWORD|Measure unit of address|£BYTE|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
IEP_CLIDAT(iep,0,0,1,200,0);
>


[*] (fnc) IEP_CLIBUF : Set the IEP CLI default BUF for read/write operation.
Remark: When you specify a buf   if the other condition is not set , is set for both

< 1.IEP_CLIBUF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEP_CLI|PTR||valid IEP CLI ptr||
BUF|PTR||valid Buf||
FOR|symb|£READ;£WRITE|you can use two distinct buffer|READ|TES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=BUF_NEW(1000,£U8);
IEP_CLIBUF(iep_buf);
>


[*] (fnc) IEP_CLIRD : Read data from a remote IEP SRV into a BUF
Related: IEP_CLI_WR
Remark: Offset  is in the same unit of OFFSETunit parameter expressed  IEP_CLIDAT

< 1.IEP_CLIRD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEP_CLI|PTR||valid IEP CLI ptr||
OFFSET|NV||Offset 1bsd||YES
SIZ|NV||In byte||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|>0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
res=IEP_CLIRD(iep);         >>> Read all the area ;

res=IEP_CLIRD(iep,1,20);    >>> Read only the first part of the area ;
>


[*] (fnc) IEP_CLIWR : Write data  from BUF to a remote IEP SRV
Related: IEP_CLIRD
Remark: Offset  is in the same unit of OFFSETunit parameter expressed  IEP_CLIDAT

< 1.IEP_CLIWR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
IEP_CLI|PTR||valid IEP CLI ptr||
OFFSET|NV||Offset 1bsd||YES
SIZ|NV||In byte||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|>0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
res=IEP_CLIWR(iep);          >>>Write all the area ;

res=IEP_CLIWR(iep,1,20);     >>> Write only first 20 bytes of the buffer ;
>


[*] (fnc) FTP_NEW : Create a Ptr to a FTP Server

< 1.FTP_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ADDRESS|symb||IA of server||
USER|synb||user name||yes
PASSWORD|symb||password||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
ftpP=FTP_NEW("192.168.2.144","xplab","xppsw")
>


[*] (fnc) FTP_DIR : Set or get remote or local directory

< 1.FTP_DIR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||
DIRECTORY|symb||Directory||yes
SELECTOR|symb|£LOC(lget/set ocal); £RMT(get/set remote);£LST(list remote)|||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
LIS|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_DIR(ftpP,NULL,£LOC)         >>> "c:\PWK-PRG\"
>


[*] (fnc) FTP_GET : Copy  a remote file to local directory

< 1.FTP_GET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||
FILE|symb||remote file name||
LOCName|symb||the new name on local machine||yes
POSTACTION|symb|NULL;£DEL(delete from remote after get)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_GET(ftpP,"report.txt",NULL,£DEL)       
>>> get "report.txt" from server and delete it
>


[*] (fnc) FTP_MGET : Copy  a multiple remote file to local directory

< 1.FTP_MGET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||
FILE|symb||remote file name (accept wild cards)||
POSTACTION|symb|NULL;£DEL(delete from remote after get)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_GET(ftpP,"*.txt",£DEL)       
>>> get all txt files from server and delete them
>


[*] (fnc) FTP_PUT : Copy a local file on remote FTP server

< 1.FTP_PUT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||
FILE|symb||local file name||
RMTName|symb||the new name on remote machine||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_PUT(ftpP,"setTest.txt","set.txt") 
>>> copy setTest.txt to server, renaming it "set.txt"
>


[*] (fnc) FTP_DEL : Delete a remote file

< 1.FTP_DEL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||
FILE|symb||remote file name (accept wild cards (tbv))||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_DEL(ftpP,"set.txt")
>>> delete "set.txt" on the server
>


[*] (fnc) FTP_STS : Return connection status

< 1.FTP_STS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_STS(ftpP)    >>> 1 if connected
>


[*] (fnc) FTP_RECON : Reconnect wit stored parameter

< 1.FTP_RECON 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FTP|PTR||valid pointer to FTP||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
FTP_RECON(ftpP)     >>> reconnect to remote server
>


[*] (fnc) WEB_NEW : Create an WEB server
Related: WEB_SSL

< 1.WEB_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ADDRESS|symb||IA on which belongs the server||
PORT|NV||Usually 80, 443 (HTTPS)||
DIRECTORY|symb||WEB root directory||
NAME|symb||WEB name||
FLAG|symb||£SSL for  HTTPS|N:A.|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
wptr=WEB_NEW(0,80,"Mywebdir", "MyWeb"); !!HTTP;

Swptr=WEB_NEW(0,443,"Mywebdir", "MyWeb", £SSL); !!HTTP;
res=WEB_SSL(Swptr,PathToCrt, PathToKey);
>


[*] (fnc) WEB_SSL : Set CRT and KEY for HTTPS
Related: WEB_NEW WEB_CERT

< 1.WEB_SSL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
SWEB_PTR|PTR||A PTR to a WEB with £SSL||
FILE_CERT|symb||File Cert||
FILE_KEY|symb||File Key||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
Swptr=WEB_NEW(0,443,"Mywebdir", "MyWeb", £SSL); !!HTTP;

res=WEB_SSL(Swptr,PathToCrt, PathToKey);
>


[*] (fnc) WEB_CERT : Create Self signed CERT and Key file
Related: WEB_NEW WEB_SSL

< 1.WEB_CERT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE_CERT|symb||File Cert||
FILE_KEY|symb||File Key||
CN|Symb||Common Name||
VALIDITY|NV||days|365|YES
KEY_LEN|NV||Key len in bit|2048|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
rs=WEB_CERT("myCert.crt","MyKet.key","www.MyWeb.com")
>


[*] (fnc) WEB_SET : Set TRIG Parameters for manage client request
Remark: Only GET, POST,DELETE,OPTION, DEFAULT  are implemented.

< 1.WEB_SET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WEB|PTR||to a valid WEB||
COMMAND|symb|£GET;£POST;£HEAD;
£OPTIONS;£PUT;£DELETE;£TRACE;£CONNECT;£DEFAULT|Command to which associate the TRIG||
TRIG|PTR||The TRIG to activate||

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
TRIG parameters are for TRIG CALL: WEB (PTR); SOK (PTR); rqsMth; rqsUrl; rqsVer; rqsQry (LIS PTR); rqsSes (UID of the session); KB1 ; TRIG return in rqsRes its reply (1=close connection, 0=Keep open).

KB1 contains a CONPAR item and if a query is detected a QRY sub item in this case, the also rqsQry contains the LIS of the query parameters.

To access KB1 attribute you must use ref:

kb1_qry(kb1,"ref('CONPAR.Content-Length')");
>


[*] (fnc) WEB_CMD : Command WEB

< 1.WEB_CMD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WEB|PTR||to a valid WEB||
COMMAND|symb|£START;£STOP|||

[RETURN|TYPE|VALUES|COMMENT]
>


[*] (fnc) WEB_FIL : Send a file
Related: WEB_TXT WEB_BUF
Remark: To be used inside a TRIG

< 1.WEB_FIL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WEB|PTR||to a valid WEB||
SOK|PTR||PTR to SOK||
FILENAME|symb||File to send||
WithName|symb||The name to show instead  of Filename||YES
HEADERINFO|symb||To put in the header||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR
>


[*] (fnc) WEB_TXT : Send a Text
Related: WEB_FIL WEB_BUF
Remark: To be used inside a TRIG

< 1.WEB_TXT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WEB|PTR||to a valid WEB||
SOK|PTR||PTR to SOK||
FILENAME|symb||a name with dot extension||
TEXT|symb||The text to send||
HEADERINFO|symb||To put in the header||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR
>


[*] (fnc) WEB_BUF : Send a Text
Related: WEB_FIL WEB_TXT
Remark: To be used inside a TRIG

< 1.WEB_BUF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WEB|PTR||to a valid WEB||
SOK|PTR||PTR to SOK||
FILENAME|symb||a name with dot extension||
BUFPTR|symb||a PTR to a buf||
HEADERINFO|symb||To put in the header||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR
>


[*] (fnc) WEB_RPL : Send an WEB/1.1 reply
Remark: in the form of : 
WEB/1.1 code text CRLF
trailer CRLF

< 1.WEB_RPL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WEB|PTR||to a valid WEB||
SOK|PTR||PTR to SOK||
CODE|NV||WEB/1.1 reply code||
TEXT|symb||Reply text||
TRAILER|symb||Reply Trailer||YES

[RETURN|TYPE|VALUES|COMMENT]
Example||
>


[*] (fnc) DT_TIME : Get or set Sys or Loc Time
Remark: Setting the time can be limited by Windows, in many case you must start the program with administrator right.

< 1.DT_TIME - USE: Set or get Date and Time

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WHAT|symb|£LOC;£SYS||LOC|
YEAR|NV||||yes
MONTH|NV||(1-12)||yes
DAY|NV||(1-31)||yes
HOUR|NV||(0-23)||yes
MINUTE|NV||(0-59)||yes
SECOND|NV||(0-59)||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DT_TIME(£LOC) ; ===> 2016-06-22 09:10:01
>


[*] (fnc) DT_TS : Generate a Time Stamp
Remark: Base for TS is January 1st 00:00:00 1970. Ifnì called without parameters return NOW TS

< 1.DT_TS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
YEAR|NV||||yes
MONTH|NV||(1-12)||yes
DAY|NV||(1-31)||yes
HOUR|NV||(0-23)||yes
MINUTE|NV||(0-59)||yes
SECOND|NV||(0-59)||yes
DAYLIGHT|NV|-1;0;1|Day light selector|0|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DAYLIGHT selector:
- Zero (0) to indicate that standard time is in effect.
- A value greater than 0 to indicate that daylight saving time is in effect.
- A value less than zero to have the C run-time library code compute whether standard time or daylight saving time is in effect.
>


[*] (fnc) DT_TSDEC : Decode a TS (time stamp), or set CLOCK OFFset
Remark: if TS is not provided CLOCK is used,

< 1.DT_TSDEC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TS|NV|||CLOCK|YES
SELECTOR|symb|£DD(day);£MM(month);£YY(year);£HH(hour);£MN(minute);£SS(second);£DW(day of week);£YD(day of the year);£HTTP(HTTP Time stamp);£ALL(date and time)|||
TYPE||£LOC;£LOCSLR(Solar);£ABS|LOCal or ABSolute|£LOC|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|
DT|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DT_TSDEC(CLOCK,£YY)           >>> 2020
DT_TSDEC(CLOCK,£HTTP)         >>> "Wed, 03 Jun 2020 08:45:31 GMT"
>


< 2.DT_TSDEC - USE: Set the CLOCK OFFset

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DELTA|NV||OFFset in second||
SELECTOR|symb|£OFF|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
CLOCK;               >>> 159127699
DT_TSDEC(-10,£OFF);

!!! After 10 seconds since the first clock;
CLOCK;               >>> 159127699 (now clock gives values decreased by 10)
>


[*] (fnc) GUI_OPN : Create or Load a GUI
Related: GUI_SRV
Remark: From a GUI item (to be passed as address)  or from a .pki file

< 1.GUI_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUIREF|symb||Address ($) of a GUI item [or .pki file name (*)]||
IA|symb||IA|127.0.0.1|yes
PORT|NV||PORT|1956|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
\gMain is a GUI with _AUTOLOAD_="OFF"
There has to be a GUI.EXE active at ip and port specified in the example (1956 is the local default port for GUI).

GUI_OPN($\gMain,"192.168.2.144",1956).

_PTR_ in \gMain will be set to pointer. Before load you can edit _FILE_ in order to load a specified page.

* NOTE
It's possible to load a page using GUIREF = "pki file name". It generates a CLI pointer to the page, that you can use to show or hide the loaded page. But it is not possible to reference to trig or to internal data.
A page opened in this way can be useful to take advantage of the send and receive functionality of the files, not to burden the interaction with the other existing GUIs
>


[*] (fnc) GUI_ALV : Check if the connection is alive

< 1.GUI_ALV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUIREF|symb||Address ($) of a GUI item or .pki file name||
TMO|NV||ms time out|1000|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
RES|NV|-2

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
GUI_ALV(_PTR_@\gMain,1000)
>> 1 : ok, comunication active
>> -2, after 1 second, timeout, GUI is not connected.
>


[*] (fnc) GUI_SND : Send a command to the GUI
Remark: FOR EXEC : To use e different separator (;) use _SEP=X where X is the sep to use

< 1.GUI_SND 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||valid GUI pointer||
COMMAND|symb|£SHOW;£HIDE;
£TOMIN(reduce pag to icon);£TONRM(normalize page from icon);
£CLOSE;£DISABLE;£ENABLE;£EXEC,£CURSOR,£SEND_KEY:(see example)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
GUI_SND(_PTR_@\GUI,"EXEC:_OS_SHELL_;SHOW;;<path\filename>;");            >>> open filename on GUI PC
>


[*] (fnc) GUI_MOUSE : Get mouse values

< 1.GUI_MOUSE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||valid GUI pointer||
SELECTOR|symb|£NULL( return change counter);£X ;£Y;£Xw(screen);£Yw(screen);£Xc(control);£Yc(control);£ON(if on the page);£Bl(button left);£BR(Button right)|||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
GUI_MOUSE(_PTR_)      >>> return a value that changes  whenever a mouse interaction               
                          involves the page. It can be a click, a movement ...
>


[*] (fnc) GUI_DUPNEW : Duplicate a GUI
Related: GUI_DUPNEW

< 1.GUI_DUPNEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUIREF|NV||Address ($) of a GUI item||
NEWGUIMANE|symb||the  name of the duplicated GUI||
ALIAS|symb|£NO;£YES|if yes an alias is created||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
CREATE
------------
newGuiNam="\Calc_"++conCnt@\Main;
guiDupPtr=GUI_DUPNEW($(\Calc),newGuiNam,£YES);

smf(1,£LCKS)
conNum@\Main=conNum@\Main+1; !!Increment reference cont;
smf(1,£LCKR)

opnPtr=GUI_OPN(guiDupPtr,guiIp,guiPort);
!!opnPtr is equivalent to REF("_PTR_@"++newGuiNam);
GUI_SND(opnPtr,£SHOW);


DESTROY
-------------

GUI_DUPDEL(guiDupPtr); !! no need to TRASH;

SMF(1,£LCKS);
conNum@\Main=conNum@\Main-1;
SMF(1,£LCKR);
>


[*] (fnc) GUI_DUPDEL : Delete a Duplicated GUI
Related: GUI_DUPNEW
Remark: The gui is also TRASHed

< 1.GUI_DUPDEL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUIREF|NV||Address ($) of a GUI item||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
see GUI_DUPNEW
>


[*] (fnc) GUI_STREAM : send a stream image to the gui
Related: BUF, OCV_MAT

< 1.GUI_STREAM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||Valid Pointer to a GUI||
IMAGE_ADDRESS|NV||$address of a IMAGE item||
SOURCE|PTR||to BUF or ocv MAT||
ASYNC|NV||0=SYNC, 1=ASYNC, >1= ASYNC with Notification, see example|0|YES
WIDE|NV||in pixel||YES
HEIGHT|NV||in pixel||YES
LINE|NV||line (row) size in byte||YES
FORMAT|symb||Image Microsoft Format||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
r=GUI_STREAM(gui,$image@MainGui\pag\panel, mat);

!!USE OF ASYNC with notification; 

°nft=1;
r=GUI_STREAM(gui,$image@MainGui\pag\panel, mat, $°NFT);

#while(°nft); Sleep(100;#end;

!! When the stream has been sended the Notification Attrubute is Nullified;

MICROSOFT FORMAT:
Alpha,Canonical,DontCare,Format16bppArgb1555,Format16bppGrayScale,Format16bppRgb555,Format16bppRgb565,Format1bppIndexed,Format24bppRgb,Format32bppArgb,Format32bppPArgb,Format32bppRgb,Format48bppRgb,Format4bppIndexed,Format64bppArgb,Format64bppPArgb,Format8bppIndexed,Gdi,Indexed,Max,PAlph,Undefined
>


[*] (fnc) GUI_AUDIO : Capture or send audio
Related: GUI_VIDEO, BUF_AUDIO

< 1.GUI_AUDIO - USE: OPEN

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
CMD|symb|£OPN|||
MODE|symb|£IO;£I;£O;£R;£RO|I=input listen, O=Output reproduction; R=listen raw|IO|yes
COMPRESS|symb|£AUTO;£ON;£OFF||AUTO|YES
CBPTR|PTR||A PTR to a TRIG of  a LIS (LR,L)||
CHN|NV||Number of channel|1|yes
SPS|NV||Sample Per second|44100|yes
BPS|NV||Bit Per Sample|16|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|-1
RES|NV|-2
RES|NV|-3
RES|NV|-5

[EXAMPLE]
I=Input data are decompress on arrive;
R=Input data NOT decompress on arrive; 

In mode IO/RO or I/R, the CBPTR is invoked on data ready in this way:
- if TRIG define it like °trg=TRIG("\Audio\AudioRcv", "BUFaudio,TMRaudio")
where "\Audio\AudioRcv" is your EXO or MTHD having as attribute "BUFaudio" and "TMRaudio" in ms is invoked for each arriving data BUF;
- if LIS the  arriving data BUF is added to the LIS in the item LIS attribute the timer.
In any case the buffer should be deleted.
>


< 2.GUI_AUDIO - USE: Listen ON/OFF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
CMD|symb|£ON;£OFF|If OPN MODE== IO,I, RO,R||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|-3
RES|NV|-4
>


< 3.GUI_AUDIO - USE: VAD Voice Auto Detection ON/OFF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
OBJECT|symb|£VAD|||
CMD|symb|£ON;£OFF|||
LVL|NV||Audio level|600|yes
QTIME|NV||Quiet Time ms|1000|yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|-3
RES|NV|-4
>


< 4.GUI_AUDIO - USE: Send an Audio

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
CMD|symb|£SND|||
BUF|symb||PTR to an audio RAW buffer||
COMPRESS|symb|£AUTO;£ON;£OFF||AUTO|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


< 5.GUI_AUDIO - USE: Close

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
CMD|symb|£CLS|Close AUDIO connection||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) GUI_VIDEO : Capture Video from the GUI Camera
Related: GUI_AUDIO, GUI_STREAM, DRW_STREAM

< 1.GUI_VIDEO - USE: OPEN

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
CMD|symb|£OPN|||
CBPTR|PTR||A PTR to a TRIG of  a LIS|NULL|YES
MODE|symb|£RAW||NULL|YES
COMPRESS|symb|£AUTO;£ON;£OFF||£AUTO|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|-1
RES|NV|-2
RES|NV|-4
RES|NV|-5

[EXAMPLE]
If CBPTR is NOT defined a fast streaming channel is open for STREAM Functions.

If MOE!=£RAW the BUF contains the decoded image and the CBPTR is invoked on data ready in this way:
- if TRIG define it like °trg=TRIG("\Video\VideoRcv", "BUFvideo,WIDTH,HEIGHT,PIXsiz, TMRvideo")
where "\Video\VideoRcv" is your EXO or MTHD having as attribute "BUFvideo", "WIDTH", "HEIGHT", PIXsiz (in bit), TMRvideo (in ms) is invoked for each arriving data BUF;
- if LIS for each arriving data an element is added to the LIS and it contains the BUF PTR and in its attribute a  symbol with this format: 
"width;height,pixsiz(in bit);tmr".

If MODE=£RAW the BUF contains the encoded data  and it can be streamed as it is to a GUI for fast view, in this case COMPRESS=£OFF by default; 
 
Buffer should be always deleted.
>


< 2.GUI_VIDEO - USE: ON/OFF/Close

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||PTR of a GUI||
CMD|symb|£ON;£OFF;£CLS|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|-3
RES|NV|-4

[EXAMPLE]
ON/OFF can be used only if  the video was open with a CBPTR
>


[*] (fnc) GUI_FILWR : Write a file on the system (PC)of the GUI
Related: GUI_FILRD
Remark: The RMTname name can’t contain the ;

< 1.GUI_FILWR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||Valid Pointer to a GUI||
LOCname|symb||Local name||
RMTname|symb||Name at  GUI||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
Copy the file log.txt from PC with PWK software to the PC of the GUI (may be the same), renaming it 2020-05-26.txt:
GUI_FILWR("c:\archive\log.txt","c:\PWK-TMP\2020-05-26.txt")     >>> 1 = success
>


[*] (fnc) GUI_FILRD : Read a file on the system (PC)of the GUI
Related: GUI_FILWR
Remark: The RMTname name can’t contain the ;

< 1.GUI_FILRD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||Valid Pointer to a GUI||
LOCname|symb||Local name||
RMTname|symb||Name at  GUI||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
Copy the file 2020-05-26.txt from PC of the GUI to the PC with PWK software (may be the same), renaming it log.txt:
GUI_FILRD("c:\archive\log.txt","c:\PWK-TMP\2020-05-26.txt")     >>> 1 = success
>


[*] (fnc) GUI_SRV : Action on gui server
Related: GUI_OPN

< 1.GUI_SRV - USE: GUI Server registration for PSV connection

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ACTION|symb|£REG|Register a Gui Server||
SOCK|PTR||pointer to SOCK||
cbPort|NV||Call Back Port||
dclPort|NV||Declared Port||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
When a GUI connect itself to an application and  send a GUI@ip;port;PSV message
the gui should be registered as a Server provider. After this operation all GUI_OPN   on that gui are made  automatically in PSV mode: upon request is the gui that open the connection on the cbPort (that should be open on the firewall),
>


< 2.GUI_SRV - USE: GUI Server Gateway start

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ACTION|symb|£GTW|Start a gateway service||
GUI_IP|I.A.||Gui Ip||
GUI_PORT|NV||Gui port||
tmo|NV||time out for the first connection|35000|OPT

[RETURN|TYPE|VALUES|COMMENT]
PORT|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
A Gateway service is startted (with tmo limit) for client that want to connect to a remote gui,
The service is started at the PORT on the address of this application that are passed to client application.
The Gui server has to be  registered before.
>


[*] (fnc) GUI_DLGMSG : open a Message Box
Related: GUI_SND, GUI_EXCMSG(deprecated)

< 1.GUI_DLGMSG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid Gui PTR||
TITOLO|symb||Main text||
TEXT|symb||Message Text||
BUTTON|symb|£OK;£OK_CANC;£YES_NO;£YES_NO_CANC|Shown button||
ICON|symb|£ERR;£EXCLAMATION;£QUESTION;£STOP;£WARNING;£INFO|Dialog icon||
DISABLE|symb|£TRUE;£FALSE||TRUE|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
The dialog appears and is syncronous. 
t1=GUI_DLGMSG(<ptr>,”Test”,”Test text”,£OK_CANC,£QUESTION,NULL);


The dialog is shown and the code waits for an input from the dialog. In the example, at the end, t1 will value £OK or £CANCEL or NULL .
>


[*] (fnc) GUI_DLGOFD : open an Open File Dialog
Related: GUI_SND, GUI_EXCOFD(deprecated)
Remark: if multi reply files names are separated by semi colon

< 1.GUI_DLGOFD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
MULTISELECT|symb|£TRUE;£FALSE|Allow multi selection ?|FALSE|YES
FILENAME|symb||Proposed file name|NULL|YES
DEF_EXTENTION|symb||default file extention|NULL|YES
INI_DIR|symb||Initial directory|NULL|YES
FILTER|symb||Filter string|All files (*.*)|*.*|YES
RESTORE_DIR|symb|£TRUE;£FALSE|If after the selection the directory should be restored|TRUE|YES
CHECK_FILE|symb|£TRUE;£FALSE|If file existence should be checked|TRUE|YES
TITLE|symb||Page title||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
fn=GUI_DLGOFD(_PTR_@\MP,£FALSE,NULL,NULL,NULL,"Kb1|*.kb1|All files(*.*)|*.*",£FALSE,£TRUE,"test");
~fn==0 >>> user aborted or error
>


[*] (fnc) GUI_DLGSFD : open an SAVE File Dialog
Related: GUI_SND, GUI_EXCSFD(deprecated)

< 1.GUI_DLGSFD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
FILENAME|symb||Proposed file name|NULL|YES
DEF_EXTENTION|symb||default file extention|NULL|YES
INI_DIR|symb||Initial directory|NULL|YES
FILTER|symb||Filter String|All files (*.*)|*.*|YES
RESTORE_DIR|symb|£TRUE;£FALSE|If after the selection the directory should be restored|TRUE|YES
TITLE|symb||Page title||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
fn=GUI_DLGSFD(_PTR_,"log.txt",NULL,NULL,"Txt files (*.txt)|*.txt",£FALSE,"Save file name");
~fn==0 >>> user aborted or error
>


[*] (fnc) GUI_DLGFLD : open an Folder browser Dialog
Related: GUI_SND, GUI_EXCFLD(deprecated)
Remark: you must wait for the reply

< 1.GUI_DLGFLD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
PATH|symb||Initial Path|NULL|YES
NEWFOLDER|symb|£FALSE;£TRUE|Show New Folder Button|FALSE|YES
DESCRIPTION|symb||Description||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
dir=GUI_DLGFLD(_PTR_,NULL,£FALSE,"Select a folder to save to");
~dir==0     >>> user aborted or error
>


[*] (fnc) GUI_DLGCLR : open  a  COLOR dialog
Related: GUI_SND

< 1.GUI_DLGCLR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
FORMAT|symb|£#(css);£Frgb(function);
£RGBA;£name;|||
COLOR|symb||Actual color if any||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
#       like        #AA00BB
Frgb       like       rgb(20, 80, 255) or rgba(20, 80, 255, 0.6)  : 
RGBA       like       R;G;B;A;       20;40;80       or 20;40;80;255       
name       like       red, blue , yellow 

if format is non defined but there is a value the format of the value is used.
The default format is eXadecimal with A component in the high order.
>


[*] (fnc) GUI_EXCMSG : open a Message Box - DEPRECATED
Related: GUI_SND, GUI_DLGMSG
Remark: you must wait for the reply

< 1.GUI_EXCMSG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid Gui PTR||
TITOLO|symb||Main text||
TEXT|symb||Message Text||
BUTTON|symb|£OK;£OK_CANC; £YES_NO;£YES_NO_CANC|Shown button||
ICON|symb|£ERR;£EXCLAMATION;£QUESTION;£STOP;£WARNING;£INFO|Dialog icon||
DISABLE|symb|£TRUE;£FALSE||TRUE|YES
$ADDRESS|symb||where put the Reply||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR

[EXAMPLE]
The dialog appears and is asyncronous. To wait it or to catch the pressed button key:

(t1 is a local attribute)
t1=NULL;
GUI_EXCMSG(<ptr>,”Test”,”Test text”,£OK_CANC,£QUESTION,NULL,$t1);
WAITCND($t1,£NOTNULL);

The dialog is shown and the code waits for an input from the dialog. In the example, at the end, t1 will value £OK or £CANCEL.
>


[*] (fnc) GUI_EXCOFD : open an Open File Dialog - DEPRECATED
Related: GUI_SND, GUI_DLGOFD
Remark: you must wait for the reply, if multi reply files names are separated by semi colon

< 1.GUI_EXCOFD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
MULTISELECT|symb|£TRUE;£FALSE|Allow multi selection ?|FALSE|YES
FILENAME|symb||Proposed file name|NULL|YES
DEF_EXTENTION|symb||default file extention|NULL|YES
INI_DIR|symb||Initial directory|NULL|YES
FILTER|symb||Filter string|All files (*.*)|*.*|YES
RESTORE_DIR|symb|£TRUE;£FALSE|If after the selection the directory should be restored|TRUE|YES
CHECK_FILE|symb|£TRUE;£FALSE|If file existence should be checked|TRUE|YES
ADDRESS|symb||where put the Reply ($)||YES
TITLE|symb||Page title||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR
>


[*] (fnc) GUI_EXCSFD : open an SAVE File Dialog - DEPRECATED
Related: GUI_SND, GUI_DLGSFD
Remark: you must wait for the reply

< 1.GUI_EXCSFD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
FILENAME|symb||Proposed file name|NULL|YES
DEF_EXTENTION|symb||default file extention|NULL|YES
INI_DIR|symb||Initial directory|NULL|YES
FILTER|symb||Filter String|All files (*.*)|*.*|YES
RESTORE_DIR|symb|£TRUE;£FALSE|If after the selection the directory should be restored|TRUE|YES
ADDRESS|symb||where put the Reply ($)||YES
TITLE|symb||Page title||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR
>


[*] (fnc) GUI_EXCFLD : open an Folder browser Dialog - DEPRECATED
Related: GUI_SND, GUI_DLGFLD
Remark: you must wait for the reply

< 1.GUI_EXCFLD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GUI|PTR||A valid GUI PTR||
$ADDRESS|symb||where put the Reply||
PATH|symb||Initial Path|NULL|YES
NEWFOLDER|symb|£FALSE;£TRUE|Show New Folder Button|FALSE|YES
DESCRIPTION|symb||Description||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|ERR
>


[*] (fnc) LIS_NEW : Create a LIS empty or with given par
Related: LIS_CLN

< 1.LIS_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|symb||symb to put in the LIS||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[EXAMPLE]
a=LIS_NEW();   >>>    a is a empty list PTR

b=LIS_NEW(“1”,”2”,”3”);  >>>    b is list (“1”,”2”,”3”) PTR
>


[*] (fnc) LIS_CLN : Create a new LIS clone of another LIS
Related: LIS_NEW

< 1.LIS_CLN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||PTR to the LIS to clone||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);   
b=LIS_CLN(a);  >>> b is the copy of a
>


[*] (fnc) LIS_SMF : operation on LIS semaphore
Related: DOOR, SMF
Remark: deprecated use the SMF of the PTR

< 1.LIS_SMF - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to LIS|PTR||PTR to LIS||
cmd|symb|£LCKS(lock 1 level);£LCKR (unlock 1 level);£RST (fully unlock);£TRY(try to lock);£OWN(return the thread owning);£WAIT(wait until is Locked) ;£WAITCNT(count of waiting Thr)|Possible command||YES

[RETURN|TYPE|VALUES|COMMENT]
Locks|NV|
Status|NV|
Thread|NV|
>


[*] (fnc) LIS_NUM : The number of symbol contained in the list

< 1.LIS_NUM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[EXAMPLE]
a=LIS_NEW(); 
LIS_NUM(a);          >>>    0

b=LIS_NEW(“1”,”2”,”3”);
LIS_NUM(b);          >>>    3
>


[*] (fnc) LIS_USE : Use content of a list as parameter for function
Remark: the LIS is preserved

< 1.LIS_USE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
SEPARATOR|symb||symb used to separate item||yes
TERMINATOR|symb||symb added to the end||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|slist|

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
CAT(LIS_USE(a));    >>>    “123”
CAT(LIS_USE(a,”,”,”;”));    >>>    “1,2,3;”
>


[*] (fnc) LIS_CLPS : COLLAPSE  the content of a list in a symbol
Remark: the LIS is preserved

< 1.LIS_CLPS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
SEPARATOR|symb||symb used to separate item||yes
TERMINATOR|symb||symb added to the end||yes

[RETURN|TYPE|VALUES|COMMENT]
RES|slist|

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
b=LIS_CLPS(a);      >>>    “123”
>


[*] (fnc) LIS_PSH : Push an slist of symbols at the begin of a LIS (stack way)

< 1.LIS_PSH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
PARLIST|slist||symbol to push||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|NV|NULL

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
LIS_PSH(a,”a”,”b”,”c”);
   >>>    list (“c”,”b”,”a”,”1”,”2”,”3”)
>


[*] (fnc) LIS_POP : Get out the first symbol of LIS
Remark: After the POP the first  remaining symbol became the current

< 1.LIS_POP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|
RES|NV|NULL

[OnError|TYPE|VALUES|COMMENT]
RES|NV|NULL

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
LIS_POP(a);    >>>    1
LIS_NUM(a);    >>>    2
LIS_POP(a);    >>>    2
LIS_NUM(a);    >>>    1
LIS_POP(a);    >>>    3
LIS_NUM(a);    >>>    0
LIS_POP(a);    >>>    NULL
LIS_NUM(a);    >>>    0
>


[*] (fnc) LIS_ADD : Add a list of symbols at the end of a list

< 1.LIS_ADD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
PARLIST|slist||symbols to add||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|NV|NULL

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
LIS_ADD(a,”a”,”b”,”c”);
   >>>    list (“1”,”2”,”3”,”a”,”b”,”c”)
>


[*] (fnc) LIS_INS : Insert a symbol in the LIS

< 1.LIS_INS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
WHERE|symb|£BEF(before);£AFT(after);£BEG(begin);£END(end)|£BEF and £AFT are relative to the cursor current position||
PARLIST|symb||Symb to insert||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|NV|NULL

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
LIS_INS(a,2,”a”,”b”,”c”);
   >>>    list (“1”,”a”,”b”,”c”,”2”,”3”)
LIS_INS(a,£END,”The”,”End”);
   >>>    list (“1”,”a”,”b”,”c”,”2”,”3”,”The”,”End”)
>


[*] (fnc) LIS_GET : Get out the symbol at the current position or if provided , the position number

< 1.LIS_GET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
POS|NV||1bsd position||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|NULL|

[EXAMPLE]
a=LIS_NEW(“1”,”2”,”3”);
LIS_GET(a);          >>>    “3”
                >>>    list (“1”,”2”)
>


[*] (fnc) LIS_POS : Set the current position in the list and return the symbol

< 1.LIS_POS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
POS|symb|###(NV request symbol position 1bsd); £BEG (begin of list);£END (end of list);£NXT (next);£PRV (previous);£CUR;£ATT(Attribute of the current symbol)|£NXT and £PRV are relative to the current position, With £CUR the current position is unchanged||
NEWVAL|symb||Set a new  value||yes
OPTION|symb|£ATT|if POS is a NV||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|NV|NULL

[EXAMPLE]
!!! create a list with 4 element, named 'p1','p2',...
°l1=LIS_NEW(£p1,£p2,£p3,£p4);

!!! returns the first element and sets the current position to the first
LIS_POS(°l1,£BEG)                           → "p1"

!!! returns the next value with respect to the current position and sets it to the new position (the 2nd)
LIS_POS(°l1,£NXT)                           → "p2"

!!! returns the 4th position value and sets the current position to the 4th 
LIS_POS(°l1,4))

!!! sets the attribute of the current element (the 4th) to 'last'
LIS_POS(°l1,£ATT,£last)

!!! sets the attribute of the specified position (the 3rd) to 'hello'
LIS_POS(°l1,3,"hello",£ATT)

!!! reads the attribute of the 2nd position (not defined, so £) 
LIS_POS(°l1,2,NULL,£ALL)              → £

!!! reads the attribute of the 4th position
LIS_POS(°l1,2,4,£ALL)                     → "last"
>


[*] (fnc) LIS_CLR : Clear a LIS

< 1.LIS_CLR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
lis=LIS_NEW(1,2,3);
LIS_NUM(lis);              >>> 3, number of elements

LIS_CLR(lis);
LIS_NUM(lis);              >>> 0
>


[*] (fnc) LIS_SORT : Order a lis by Val or Att

< 1.LIS_SORT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
LIS|PTR||A valid PTR to LIS||
ORDER|symb|£ASC;£DSC||£ASC|YES
BY|symb|£VAL;£ATT||£VAL|YES
AS|symb|£AUTO;£SYMB;£NUM||£AUTO|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
lis=LIS_NEW(2,1,11,31,3);
LIS_SORT(lis);
CAT(LISUSE(lis,","));               >>> 1,2,3,11,31
>


[*] (fnc) LIS_SRCH : Search a symbol in a list.
Remark: The comparison is case insensitive and initial & final space insensitive.

< 1.LIS_SRCH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||
SEARCH|symb||the symbol to search||

[RETURN|TYPE|VALUES|COMMENT]
POS|NV|
POS|NV|0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
lis=LIS_NEW(£pietro,£paolo,£filippo);

LIS_SRCH(lis,£paolo);         >>> 2, "paolo" is in the second position 
LIS_SRCH(lis,£attilio);       >>> 0, not found
>


[*] (fnc) LIS_2TBL : Return a TBL with the same content of the lis
Remark: The TBL has two columns : ITEM and ATTribute

< 1.LIS_2TBL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PAR|PTR||A valid PTR to LIS||

[RETURN|TYPE|VALUES|COMMENT]
TBL|PTR|
>


[*] (fnc) INI_NEW : Create an INI object  if file name is given that file is opened.
Related: INI_LOD
Remark: Default delimiter id semi column  also # is used

< 1.INI_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILE|symb||File to Load||YES
DELIMITER|symb||Delimiter|;|YES

[RETURN|TYPE|VALUES|COMMENT]
INI|PTR|

[EXAMPLE]
iniP=INI_NEW();            >>> Create empty ini file

iniP=INI_NEW("test.ini");  >>> Open "test.ini" (also if file not exists -> empty)
>


[*] (fnc) INI_LOD : Load a file

< 1.INI_LOD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
FILE|symb||File to load||
DELIMITER|symb||Delimiter|;|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_LOD(iniP,"test.ini")   >>> open test.ini in preexisting iniP pointer
>


[*] (fnc) INI_SAV : Save INI file

< 1.INI_SAV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
FILE|symb||File to save||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_SAV(iniP)
>


[*] (fnc) INI_LBLNUM : Number of  label

< 1.INI_LBLNUM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||

[RETURN|TYPE|VALUES|COMMENT]
NUM|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_LBLNUM(iniP)           >>> number of label (0 for empty ini)
>


[*] (fnc) INI_KEYNUM : Number of  key inside a label

< 1.INI_KEYNUM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
LABELnum|NV||Number of label instance 1bsd|IN ALL LABEL instance|YES

[RETURN|TYPE|VALUES|COMMENT]
NUM|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYNUM(iniP,£Server)     >>> number of keys inside label £Server
>


[*] (fnc) INI_LBLCOUNT : Number of instance of a label

< 1.INI_LBLCOUNT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||

[RETURN|TYPE|VALUES|COMMENT]
NUM|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_LBLCOUNT(iniP,£Server)          >>> Instance of label £Server
>


[*] (fnc) INI_KEYCOUNT : Number of instance of a key inside a label

< 1.INI_KEYCOUNT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
KEY|symb||Key name||
LABELnum|NV||Number of label instance 1bsd|IN ALL LABEL instance|YES

[RETURN|TYPE|VALUES|COMMENT]
NUM|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYCOUNT(iniP,£Server,£IP)         >>> Instances of  key IP in label £Server
>


[*] (fnc) INI_LBLLIST : Name of the label
Related: INI_LBLNUM

< 1.INI_LBLLIST 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABELnum|NV||Number of label instance|1|YES

[RETURN|TYPE|VALUES|COMMENT]
LABEL|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_LBLLIST(iniP,1)         >>> First label of ini
>


[*] (fnc) INI_KEYLIST : name of a key inside a Label

< 1.INI_KEYLIST 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
LABELnum|NV||Number of label instance|IN ALL LABEL instance|YES
KEYnum|NV||Number of key instance|1|YES

[RETURN|TYPE|VALUES|COMMENT]
KEY|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYLIST(iniP,£Server)       >>> First key of first instance of £Server label
>


[*] (fnc) INI_KEYGETSET : Get the Value of key if not exist set with a value
Remark: Operate on the first instance

< 1.INI_KEYGETSET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
KEY|symb||Key Name||
VALUE|symb||Key value||

[RETURN|TYPE|VALUES|COMMENT]
KEYVAL|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYGETSET(iniP,£Server,£IP,"192.168.2.144")    
>>> se value of key £IP in £Server label
>


[*] (fnc) INI_KEYGET : Get the Value of key

< 1.INI_KEYGET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
KEY|symb||Key Name||
LABELnum|NV||Number of label instance|IN ALL LABEL instance|YES
KEYnum|NV||Number of key instance|1|YES

[RETURN|TYPE|VALUES|COMMENT]
KEYVAL|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYGET(iniP.£Server,£IP)    >>> "192.168.2.144"
>


[*] (fnc) INI_KEYSET : Set the value of a key

< 1.INI_KEYSET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
KEY|symb||Key Name||
KEYVALUE|symb||Key value||
LABELnum|NV||Number of label instance|1|YES
KEYnum|NV||Number of key instance|1|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|nv|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYSET(iniP,£Server,£IP,"192.168.2.144")    
>>> se value of key £IP in £Server label
>


[*] (fnc) INI_LBLADD : Add a label if not already exist if  ALWAYS is set ad a new one

< 1.INI_LBLADD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
ALWAYS|symb|NULL;£TRUE|Add also if exists|£TRUE|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_LBLADD(iniP,£Server)    >>> add label £Server to iniP
>


[*] (fnc) INI_LBLDEL : Delete a label instance

< 1.INI_LBLDEL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
LABELnum|NV||Number of label instance|ALL LABEL instance|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_LBLDEL(iniP,£Server) >>> delete label £Server from iniP
>


[*] (fnc) INI_KEYADD : Add a Key to a label

< 1.INI_KEYADD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
KEY|symb||Key Name||
KEYVALUE|symb||Key value||
LABELnum|NV||Number of label instance|1|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYADD(iniP,£Server,£PORT,5000)  
>>> add key £PORT to label £Server with value 5000
>


[*] (fnc) INI_KEYDEL : Delete a Key instance

< 1.INI_KEYDEL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||
LABEL|symb||Label name||
KEY|symb||Key Name||
LABELnum|NV||Number of label instance|ALL LABEL instance|YES
KEYnum|NV||Number of key instance|ALL LABEL instance|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_KEYDEL(iniP,£Server,£PORT)  >>> delete key £PORT from label £Server
>


[*] (fnc) INI_CLEAR : Clear INI

< 1.INI_CLEAR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
INI|PTR||Pointer to INI||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
INI_CLEAR(iniP)   >>> flush iniP pointer
>


[*] (fnc) NTW_GHBN : Get Host by name (internet name resolution)

< 1.NTW_GHBN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NAME|symb||Host name||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
NTW_GHBN("WIN-FPHJIHOAIPM")  >>> "172.31.63.234"
>


[*] (fnc) NTW_GHBA : Get Host by Address (internet name resolution)

< 1.NTW_GHBA 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NAME|symb||Host name||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
NTW_GHBA("192.168.2.144")    >>> "WIN-FPHJIHOAIPM"
>


[*] (fnc) NTW_PING : Ping Host

< 1.NTW_PING 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
HOST|symb||Host||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1
RES|NV|0

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
NTW_PING("192.168.2.144")      >>> 1, pc is responding
NTW_PING("192.168.2.145")      >>> 0, pc is not responding
>


[*] (fnc) PKG_OPN : Open a Package without  arguments open the current  assembly package

< 1.PKG_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NAME|symb||Package  name||YES
NAME|symb|NULL;£NEW|if not exists create a new pkg||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
PKG_OPN("c:\PWK-PRG\stressGui.pwk")     >>> pointer to PKG
>


[*] (fnc) PKG_MNFGET : Giving a Section and a name of a package item return the value
Remark: If PKG is null current assembly package is assumed

< 1.PKG_MNFGET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PKG|PTR||PTR||YES
SECTION|symb||Package Section name||
NAME|symb||Item name||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
PKG_MNFGET(pkgPtr,£Resources,£BKG)    >>>  "SFD_YELLOW_1280x1024.png"
>


[*] (fnc) PKG_MNFADD : Add or change an item value in a section
Remark: If PKG is null current assembly package is assumed

< 1.PKG_MNFADD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PKG|PTR||PTR||YES
SECTION|symb||Package Section name (must exist)||
NAME|symb||Item name||
VALUE|symb||item value||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
PKG_MNFADD(pkgPtr,£Resources,£BKG,"newBackgroud.png")   >>> Change background image
>


[*] (fnc) PKG_SAV : Save back  the package
Remark: If PKG is null current assembly package is assumed;
Save only  items declared into the package. This function does NOT WORK in WorkBench. If nor SECTION and ELEMENT are defined all package is saved back. If only SECTION is defined  the all SECTION contents are saved. If PKG is null assembly package is assumed.

< 1.PKG_SAV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PKG|PTR||PTR||YES
SECTION|symb||||YES
ELEMENT|symb||||YES

[RETURN|TYPE|VALUES|COMMENT]

[EXAMPLE]
PKG_SAV(pkgPtr,£Resources,£BKG)    >>> Save Resources.BKG of the package
>


[*] (fnc) PKG_PTH : Get the package path
Remark: If PKG is null assembly package is assumed

< 1.PKG_PTH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PKG|PTR||PTR||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
PKG_PTH(pkgPtr)    >>> "C:\PWK-TMP\stressGui-1590739115-2416\ "
PKG_PTH()          >>> "C:\PWK-TMP\PWK-ISP-07-1590671330-13252\ " current package
>


< The Backslash 
< Item Creation 
[*] () Item operations : item='new name';
Related: item=@;

< Tag operations 
< Attribute operations 
< Basic Queries (BQ) 
< KB1 Operators ans functions 
< In BQ  you can use comparison operators,  multiple assignment. 
< Create, set, change 
< Queries (TEXT  result) 
< Special KB1 Operators and Functions 
[*] (KB1-fnc) COUNTLIS : Return the number of element of a SLIS or XLIS returned by query
Remark: The S/XLis is deleted

< 1.COUNTLIS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
LIS|PTR||||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (KB1-fnc) GETREF : Return an XLIS of  ITEMs useful to be copied with KB1_XCOPY

< 1.GETREF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
QUERYres|PTR||SLIS or XLIS||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (KB1-fnc) EXTRACT : Return an XLIS of COPIED  ITEMs useful to use  with KB1_XNS
Related: UNLINK
Remark: The function accept multi parameters of both type (Queries or with name change)

< 1.EXTRACT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
QUERYres|PTR||XLIS or SLIS||YES
ItemName=NewName|symb||If =NewName exists the Item get this name in the res XLIS||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
xl=EXTRACT(\MAT\);   >> extract all elements below MAT
xl=EXTRACT('\ART\Cod1=Pippo'); >> extract Cod1 and rename  it as Pippo
xl=EXTRACT(\MAT\, '\ART\Cod1=Pippo' )  >>> Both are added to xl
>


[*] (KB1-fnc) UNLINK : Return an XLIS of REMOVED ITEMs useful to use  with KB1_XNS
Related: EXTRACT
Remark: The function accept multi parameters of both type (Queries or with name change)

< 1.UNLINK 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
QUERYres|PTR||XLIS or SLIS||YES
ItemName=NewName|symb||If =NewName exists the Item get this name in the res XLIS||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
xl=EXTRACT(\MAT\);   >> extract all elements below MAT
xl=EXTRACT('\ART\Cod1=Pippo'); >> extract Cod1 and rename  it as Pippo
xl=EXTRACT(\MAT\, '\ART\Cod1=Pippo' )  >>> Both are added to xl
>


[*] (KB1-fnc) TBLATT : Return a PTR to TBL from the result of a query

< 1.TBLATT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
QRYRES|PTR||||
ATTRIBUTE|enum||||YES
SEP|synb||separator of the attribute enum|;|YES
TBLatt|symb|£NO;£YES|TBL|£NO|YES
TAGenum|symb|£NO;£YES|TBL|£NO|YES
SubQuery_1|symb||||YES
SubQuery_x|symb||||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
In column 1 : _ITEM_  Item name 
In column 2: _VAL_     Item value

If(TBLatt == £YES)
In Column 3: _ TBLATT_   PTR to attribute TBL

I(TAGenum == £YES)
In Column 3 (or 4 if TBLatt) _TAG_ comma separated enum of TAG

If ATTRIBUTE enum is defined the following column contains the values of the attribute and the column name is the attribute name.

Row name are set with the full ITEM path name 

In SubQuery (you can add as many queries you want), you can use _PATH_, _ITEM_, _VAL_ that are replaced before its execution, by the values obtained by the Main Query; results are returned in the relative column and you can set the column name adding “ AS  colname” at the end of the SQ.
>


[*] (KB1-fnc) IDCHG : Test the existence of an Item and/or of an attribute of an item

< 1.IDCHG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ITEM_ID|symb||Item ID as £||
NEW_ID|symb||new ID as £||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (KB1-fnc) EXISTS : Test the existence of an Item and/or of an attribute of an item

< 1.EXISTS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ITEM(.ATTR)|symb||Item or Item.Attribute||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) KB1_OPN : Open a knowledge Base
Related: KB1_OPN_NTHS
Remark: The FILENAME if defined is used in KB1_SAV as default – In the kb a _THIS_ is created

< 1.KB1_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb||Name of the file containing the KB||YES
TYPE|symb|NULL;£TEXT|Type of the following elem|£TEXT|YES
ELM|symb||if(TYP=TEXT) Element to load instead of the file.||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|
>


[*] (fnc) KB1_OPN_NTHS : Open a knowledge Base
Remark: The FILENAME if defined is used in KB1_SAV as default -

< 1.KB1_OPN_NTHS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb||Name of the file containing the KB||YES
TYPE|symb|NULL;£TEXT|Type of the following elem|£TEXT|YES
ELM|symb||if(TYP=TEXT) Element to load instead of the file.||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|
>


[*] (fnc) KB1_SMF : operation on KB1 semaphore
Related: DOOR, SMF
Remark: deprecated use the smf of the PTR instead

< 1.KB1_SMF - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to LIS|PTR||PTR to KB1||
cmd|symb|£LCKS(lock 1 level);£LCKR (unlock 1 level);£RST (fully unlock);£TRY(try to lock);£OWN(return the thread owning)|Possible command||YES

[RETURN|TYPE|VALUES|COMMENT]
Locks|NV|
Status|NV|
Thread|NV|
>


[*] (fnc) KB1_JSON : Convert a Json Text in KB1

< 1.KB1_JSON 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
JSON|symb||Json text||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|sym|NULL

[EXAMPLE]
JSON is The root object; Object have “OBJ” tag and if unmamed  get “_OBJ_x” name;
Array have “ARY” tag, array element   get “_AE_x” name
>


[*] (fnc) KB1_SAV : Open a knowledge Base
Remark: If FILENAME if N.D. the default is used

< 1.KB1_SAV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
FILENAME|symb||Name of the file containing the KB||YES
OPTION|symb|£PROTECT;£VISIBLE; £IFCHG;£ASYNC|with £PROTECT KB is kripted|£PROTECT, £SYNC|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[EXAMPLE]
£PROTECT / £VISIBLE are alternative; if you add £IFCHG the save operation is done only if the KB1 is changed since the last save and the name is the default name.

kb1_opn(“my.kb1”);

kb1_sav(NULL,£VISIBLE)  >>> saved with the default name

kb1_save(NULL, “VISIBLE IFCHG”) >>> save only if changed since the last save

kb1_save(“new.kb1”, “VISIBLE IFCHG”) >>> the name is changed so is saved also if not changed

If £ASYNC the save operation is made by another thread.
>


[*] (fnc) KB1_GET : Return in a symbol the serialization of the kb

< 1.KB1_GET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||||
TAB|symb|£NOT;£YES|serialization with indent tab ?|£NOT|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|
>


[*] (fnc) KB1_DLG : Make a query to a knowledge Base
Related: KB1_QRY, KB1_EXC
Remark: Lock for Read and Write. See general discussion on the manual PWK-MAN-LIB-CORE

< 1.KB1_DLG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
DLGTEXT|symb||||
FORMAT|symb|NULL;£TEXT|The result  format||YES
SEP|symb||The separator to use for Lis result|<SPACE>|YES
SEPres|symb||separator between results|<CRLF>|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[EXAMPLE]
ITEM:TYPE.ATTRIB

ITEM=itemValue                     >>> itemValue is set
ITEM:= typeValue              >>> typeValue is add
ITEM:tv= typeValue              >>> tv is changed with typeValue 
ITEM.ATTRIB=attribValue

\              >>>        LIS of item
ITEM\              >>>       LIS of sub Item
ITEM              >>>       itemValue
ITEM:              >>>       LIS of typeValue
ITEM.ATTRIB       >>>       attribValue
ITEM.              >>>       LIS of ATTRIB

To separate statement use the semi colon ;
if the Fst() of a result is:
18       a LIS of TREE item is returned and should be destroyed after the use
29       a LIS of SYMB is returned and should be destroyed after the use
>


[*] (fnc) KB1_QRY : Make a query to a knowledge Base
Related: KB1_DLG, KB1_EXC
Remark: Lock for read. See general discussion on the manual PWK-MAN-LIB-CORE,

< 1.KB1_QRY 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
DLGTEXT|symb||||
FORMAT|symb|NULL;£TEXT|The result  format||YES
SEP|symb||The separator to use for Lis result|<SPACE>|YES
SEPres|symb||separator between results|<CRLF>|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[EXAMPLE]
ITEM:TYPE.ATTRIB

ITEM=itemValue                     >>> itemValue is set
ITEM:= typeValue              >>> typeValue is add
ITEM:tv= typeValue              >>> tv is changed with typeValue 
ITEM.ATTRIB=attribValue

\              >>>        LIS of item
ITEM\              >>>       LIS of sub Item
ITEM              >>>       itemValue
ITEM:              >>>       LIS of typeValue
ITEM.ATTRIB       >>>       attribValue
ITEM.              >>>       LIS of ATTRIB

To separate statement use the semi colon ;
if the Fst() of a result is:
18       a LIS of TREE item is returned and should be destroyed after the use
29       a LIS of SYMB is returned and should be destroyed after the use
>


[*] (fnc) KB1_EXC : Make a query to a knowledge Base using an existing Formula
Related: KB1_DLG, KB1_QRY, KB1_FRM
Remark: the formula name is normalized : upper case,no spaces

< 1.KB1_EXC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
FRMname|symb||||
FORMAT|symb|NULL;£TEXT|The result  format||YES
SEP|symb||The separator to use for Lis result|<SPACE>|YES
SEPres|symb||separator between results|<CRLF>|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|
>


[*] (fnc) KB1_FRM : Operation on formulas
Related: KB1_EXC
Remark: the formula name is normalized : upper case, no spaces

< 1.KB1_FRM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
NAME|symb||Name of the formula||
CMD|symb|£INFO(actual furmula);£INS(insert or modify);£DEL(delete)||£INFO|YES
FORMULA|symb||||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) KB1_XNS : Insert a XLIS in a knowledge base
Related: KB_XCP
Remark: Usually the element of the XLIS are EXTRACT from a KB1

< 1.KB1_XNS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
XLIS|symb/PTR||“XLIS:12..” or a PTR||
PATH|symb||Where to add||OPT

[RETURN|TYPE|VALUES|COMMENT]
XLIS|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|

[EXAMPLE]
kb        : PTR to KB1
a       : could be “XLIS:123456” or a PTR to a LIS containing an XLIS 
KB1_XNS(kb, a, “\pippo”);
>


[*] (fnc) KB1_XCP : Insert a XLIS in a knowledge base, each element is copied from a reference
Related: KB1_XNS
Remark: Usually the element of the XLIS are GETREF from a KB1

< 1.KB1_XCP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||Pointer to KB||
XLIS|symb/PTR||“XLIS:12..” or a PTR||
PATH|symb||Where to add||OPT

[RETURN|TYPE|VALUES|COMMENT]
XLIS|PTR|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|

[EXAMPLE]
kb        : PTR to KB1
a       : could be “XLIS:123456” or a PTR to a LIS containing an XLIS than contains reference to item
KB1_XCP(kb, a, “\pippo”);
>


[*] (fnc) KB1_INF : Get KB1 info

< 1.KB1_INF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
KB|PTR||||
SEL|symb|£OPFNCLIS;$CHGCNT|||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|
>


[*] (fnc) TBL_NEW : Create a table from row/column or from a  text

< 1.TBL_NEW - USE: From row and column

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NCOL|NV||Number of column||
NROW|NV||Number of rows||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_NEW(2,2)      >>> Table ( "" , "" ) ( "" , "" )
>


< 2.TBL_NEW - USE: From row and column names

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
NCOL|NV||Number of column or NULL||
NROW|NV||Number of rows||
ItemSep|symb||Separator between Names|;|YES
GroupSep|symb||IGNORED||YES
COLUMNNames|enum||COLUMN names||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
If NCOL is zero or NULL is inferred by the number of COLUMNNames, If defined it set the Number of Columns

TBL_NEW(NULL,2,";",NULL,"ID;DSC" )     >>> Table ( "" , "" ) ( "" , "" ) with column 1 name "ID" and 2 "DSC"
>


< 3.TBL_NEW - USE: From Text

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TEXT|symb||data of the table||
BY|symb|£COL;£ROW|data are by col or by row||
ItemSep|symb||Separator between item||YES
GroupSep|symb||Separator between group||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
txt="luca;1;192|pino;2;174";
tbl=TBL_NEW(txt,£ROW,";","|")
>>> Table ( "luca" , "1" , "192" ) ( "pino" , "2" , "174" )
>>> column are "1", "2" and "3" , row are "1" and "2"
>


[*] (fnc) TBL_SMF : operation on TBL semaphore
Related: DOOR, SMF

< 1.TBL_SMF - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to LIS|PTR||PTR to TBL||
cmd|symb|£LCKS(lock 1 level);£LCKR(unlock 1 level);£RST(fully unlock);£TRY(try to lock);£OWN(return the thread owning);£LCKDSB(Disable TBL semaphore);£LCKENB(Enable standard smf behaviour);£WAIT(wait until is Locked) ;£WAITCNT(count of waiting Thr)|Possible command||YES

[RETURN|TYPE|VALUES|COMMENT]
Locks|NV|
Status|NV|
Thread|NV|

[EXAMPLE]
£LCKDSB should be used carefully because synchronisation is suppressed, as counter part in this way more then one thread can access the TBL without interlock.
>


[*] (fnc) TBL_CLN : Clone the TBL in a new TBL

< 1.TBL_CLN - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to TBL|PTR||PTR to LIS||

[RETURN|TYPE|VALUES|COMMENT]
CLN_TBL|PTR|
>


[*] (fnc) TBL_SAV : Save  the TBL content  in file
Related: TBL_LOD

< 1.TBL_SAV - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to TBL|PTR||PTR to LIS||
FILENAME|symb||File Name||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_SAV(tblPtr,"today.tbl") 
>> save the content of tblPTr (data, column names and row names) to today.tbl
>


[*] (fnc) TBL_LOD : Load   the TBL with the content of a file created with a previous TBL_SAV
Related: TBL_SAV

< 1.TBL_LOD - USE: Command on a SMF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PTR to TBL|PTR||PTR to LIS||
FILENAME|symb||File Name||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[EXAMPLE]
TBL_LOD(tblPtr,"today.tbl")       
>>> load the table saved in today.tbl in the tblPtr pointer (overwriting preexistent datas)

tblPtr=TBL_LOD(NULL,"today.tbl")
>>> load tje table saved in today.tbl in a new table pointer
>


[*] (fnc) TBL_CHG : Change the table dimension
Remark: If possible the content is preserved; Operator ADD SUB INS DEL can be prep-ended

< 1.TBL_CHG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
NCOL|symb|NULL;£ADD;£SUB;£INS;£DEL|new Number of column or unchanged if N.D. INS and DEL alone cause the insertion or the deletion at the First position.|actual number|YES
NROW|symb|;£ADD;£SUB;£INS;£DEL|new Number of rows or unchanged if N.D.|actual number|YES
RETVAL|symb|£PTR;£ROW;£COL|The return val|£PTR|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_CHG(tbl, 10, 20); !! set to 10 columns and 20 rows;

TBL_CHG(tbl, null, “ADD 2”); !!  add 2 rows :10 columns and 22 rows;

TBL_CHG(tbl, null, “DEL 2”); !!  Row N°2 is deleted;

TBL_CHG(tbl, “INS 3”); !!  A column is inserted BEFORE actual column 3;
 
TBL_CHG(tbl, “INS ”,”DEL”); !!  A column is inserted in the First position and the first row is deleted;
>


[*] (fnc) TBL_ITM : Get or Set The value of an item
Related: TBL_NAM
Remark: If col or row have a name that can be used instead of the number

< 1.TBL_ITM - USE: Single insertion / extraction

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
COL|symb||column number or name||
ROW|symb||row number or name||
VAL|symb||if SET the value||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


< 2.TBL_ITM - USE: Single insertion with operation on SELF value

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
COL|symb||column number or name||
ROW|symb||row number or name||
OP|SYMB|£ADD;£SUB,£MUL;£DIV|Operator||YES
VAL|symb||if SET the value||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_ITM(°tb,1,1,100);
TBL_ITM(°tb,1,1,£ADD,10);
chatput(TBL_ITM(°tb,1,1) >>> 110
>


< 3.TBL_ITM - USE: Multi insertion

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
COL|symb||column number or name||
ROW|symb||row number or name||
SELECTOR|symb|£ROW;£COL|£ROW, £COL|£ROW|
ITEMS|slis||||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
In this form can be used for multiple insert. NULL values are skipped. The selector can be followed  by a number, in this case a BLOCK insertion is intended and the number indicate the dimension: 

if SELECTOR == £ROW the number of elements for each row
if SELECTOR == £COL the number of elements  of each column

TBL_ITM( tbl, 1,1, £ROW, a,b,c,d) // row insertion

==> ROW 1: a, b, c, d;

TBL_ITM( tbl, 2,2, “ROW 2”, a,b,c,d) // row insertion (x= existing element) 2 is the row length to insert
 
==> ROW 2: x, a, b;
==> ROW 3: x, c, d;
>


[*] (fnc) TBL_NAM : Assign names to columns or rows
Related: TBL_ITM

< 1.TBL_NAM - USE: Single Assignment

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COL;£ROW|||
NUM|NV||Number 1bsd of the col or row||
NAME|symb||The name||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_NAM(tblPtr,£COL,5,£SEL)         >> name the column 5 of the tblPtr as "SEL". You can refer it as 5 or "SEL"
>


< 2.TBL_NAM - USE: Multi assignment

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COL;£ROW|||
TEXT|enum||Enumeration of names||
SEP|symb||Names separator||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_NAM(tblPtr,£COL,"ID;DSC;SEL",";")   
>>> name the columns of tblPtr : 1=ID, 2=DSC, 3=SEL

TBL_NAM(tblPtr,£COL,2)                  >>> £DSC
>


[*] (fnc) TBL_INF : TBL info

< 1.TBL_INF - USE: Without PAR

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COL;£ROW|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
tblPtr=TBL_NEW(NULL,2,";",NULL,"ID;DSC;SEL" );

TBL_INF(tblPtr,£COL)      >>> 3
TBL_INF(tblPtr,£ROW)      >>> 2
>


< 2.TBL_INF - USE: With PAR

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COL;£ROW|||
PAR|symb||Name or Number (1bsd)||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
tblPtr=TBL_NEW(NULL,2,";",NULL,"ID;DSC;SEL" );

TBL_INF(tblPtr,£COL,3)      >>> "SEL"
>


< 3.TBL_INF - USE: enum of cols  or rows  names

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COLNAMES;£ROWNAMES|||
SEP|symb||enum separator|;|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
tblPtr=TBL_NEW(NULL,2,";",NULL,"ID;DSC;SEL" );

TBL_INF(tblPtr,£COLNAMES)      >>> "ID;DSC;SEL"
>


< 4.TBL_INF - USE: Name of  one row or col

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COLNAME;£ROWNAME|||
INDEX|NV||||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) TBL_EXP : Export the table content all or partial in a symbol
Related: TBL_IMP TBL_USE TBL_BUF

< 1.TBL_EXP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
itemSep|symb||Separator between item|;|YES
groupSep|symb||Separator between group|CRLF|YES
BY|symb|£COL;£ROW||£ROW|YES
STARTcol|NV||From col||YES
STARTrow|NV||From row||YES
COLnum|NV||Number of cols||YES
ROWnum|NV||Number of rows||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
txt="luca;1;192|pino;2;174";
tbl=TBL_ITM(txt,£ROW,";","|");

TBL_EXP(tbl,";","|",£COL,3,1)        >>> "192;174"
>


[*] (fnc) TBL_BUF : Export the table content all or partial in a NV buffer
Related: TBL_IMP TBL_USE TBL_EXP

< 1.TBL_BUF 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
TYPE|symb|£U8;£I8;£U16;£I16;£U32;£I32;£F32;£U64;£I64;£F64|;|;|
BY|symb|£COL;£ROW||£ROW|YES
STARTcol|NV||From col||YES
STARTrow|NV||From row||YES
COLnum|NV||Number of cols||YES
ROWnum|NV||Number of rows||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) TBL_USE : Export the table content all or partial as separated symbol
Related: TBL_IMP, TBL_EXP

< 1.TBL_USE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
itemSep|symb||Separator between item||YES
groupSep|symb||Separator between group||YES
BY|symb|£COL;£ROW||£ROW|YES
STARTcol|NV||From col||YES
STARTrow|NV||From row||YES
COLnum|NV||Number of cols||YES
ROWnum|NV||Number of rows||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|slis|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
CAT(TBL_USE(tbl,";","|",£ROW)) is equivalent to TBL_EXP(tbl,";","|",£ROW)
>


[*] (fnc) TBL_IMP : Load the table with data
Related: TBL_EXP TBL_USE

< 1.TBL_IMP - USE: Rows and columns are adjusted in respect the data

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
DATA|symb||Data||
itemSep|symb||Separator between item|;|YES
groupSep|symb||Separator between group|CRLF|YES
BY|symb|£COL;£ROW||£ROW|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


< 2.TBL_IMP - USE: The data are inserted in the existing tbl

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
DATA|symb||Data||
itemSep|symb||Separator between item|;|YES
groupSep|symb||Separator between group|CRLF|YES
BY|symb|£COL;£ROW||£ROW|YES
STARTCOL|symb||Starting column||
STARTROW|symb||starting row||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) TBL_SRC : Search in col or row for a symb

< 1.TBL_SRC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
IN|symb|£COL;£ROW|||
NUM|symb||number (1bsd) or name of the row or col||
ITEM|symb||symb to search||
START|symb||Start row or col number or name||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) TBL_EXG : Exchange the content of two row or col

< 1.TBL_EXG 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COL;£ROW|||
This|symb||number (1bsd) or name of the row or col||
WithThis|symb||number (1bsd) or name of the row or col||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
txt="luca;1;192|pino;2;174";
tbl=TBL_ITM(txt,£ROW,";","|")

TBL_EXG(tbl,£COL,2,3)      >>> Table ( "luca" , 192 , 1 ) ( "pino" , 174 , 2 )
>


[*] (fnc) TBL_SORT : Order row or col using a row or col content as key

< 1.TBL_SORT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||Valid PTR to a TBL||
WHAT|symb|£COL;£ROW|||
KEY|symb||number (1bsd) or name of the row or col||
ORDER|symb|£ASC;£DSC||£ASC|YES
AS|symb|£AUTO;£SYMB;£NUM||£AUTO|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_SORT(tbl,£ROW,£NAME,£ASC)

Note: if the column/row used for sort contains numerical value, the sort considers they as string. So 1, 2, 3, 11, 21 sorted became 1,11,2,21,3
>


[*] (fnc) HTTP_OPN : Create an HTTP connection to a server

< 1.HTTP_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TYPE|symb|£HTTP;£HTTPS|||
HOST|symb||Host name||
PORT|NV||Port||YES
TMO1|NV||Resolve Time out|90000|YES
TMO2|NV||Connect|90000|YES
TMO3|NV||Send|90000|YES
TMO4|NV||Receive|90000|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HTTP_GET : Send a GET command to an HTTP server
Remark: (MRF) Multi reply Function

< 1.HTTP_GET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
HTTP|PTR||PTR to HTTP||
CMD|symb||HTTP command||
WHAT|symb|£TEXT;£FILE|||
ENCODING|symb|£A;£U;£UTF|||
FILENAME|symb||WHAT filename||YES
HEADEROPTION|symb||HTTP Header option||YES
REPLYTYPE|symb|NULL;£HEADER|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES1|symb|
RES2|symb|

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|NULL
>


[*] (fnc) HTTP_DEL : Send a DELETE command to an HTTP server
Remark: (MRF) Multi reply Function

< 1.HTTP_DEL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
HTTP|PTR||PTR to HTTP||
CMD|symb||HTTP command||
WHAT|symb|£TEXT;£FILE|for reply||
ENCODING|symb|£A;£U;£UTF|for replay||
FILENAME|symb||WHAT filename||YES
HEADEROPTION|symb||HTTP Header option||YES
REPLYTYPE|symb|NULL;£HEADER|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES1|symb|
RES2|symb|

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|NULL
>


[*] (fnc) HTTP_POST : Send a POSTcommand to an HTTP server
Remark: (MRF) Multi reply Function

< 1.HTTP_POST 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
HTTP|PTR||PTR to HTTP||
CMD|symb||HTTP command||
WHAT|symb|£TEXT;£FILE;£BUF|||
ENCODING|symb|£A;£U;£UTF|Ignored for BUF||
WHAT-PAYLOAD|symb||filename or TEXT or BUF PTR||
RPL-WHAT|symb|£TEXT;£FILE|||
RPL-ENCODING|symb|£A;£U;£UTF|||
RPL-FILENAME|symb||RPL-WHAT filename||YES
HEADEROPTION|symb||HTTP Header option||YES
REPLYTYPE|symb|NULL;£HEADER|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES1|symb|
RES2|symb|

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|-1
>


[*] (fnc) HTTP_PUT : Send a PUT command to an HTTP server
Remark: (MRF) Multi reply Function

< 1.HTTP_PUT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
HTTP|PTR||PTR to HTTP||
CMD|symb||HTTP command||
WHAT|symb|£TEXT;£FILE;£BUF|||
ENCODING|symb|£A;£U;£UTF|||
WHAT-PAYLOAD|symb||filename or TEXT or BUF PTR||
RPL-WHAT|symb|£TEXT;£FILE|||
RPL-ENCODING|symb|£A;£U;£UTF|||
RPL-FILENAME|symb||RPL-WHAT filename||YES
HEADEROPTION|symb||HTTP Header option||YES
REPLYTYPE|symb|NULL;£HEADER|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES1|symb|
RES2|symb|

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|-1
>


[*] (fnc) HTTP_WSC : Open a Web Socket
Related: HTTP_WSC_SND, HTTP_WSC_RCV, HTTP_WSC_INQ

< 1.HTTP_WSC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
URI|Symb||Uri of WS||
RCVBUFSIZ|NV||Receive Buffer size|20000|YES
HEADERS|symb||Optional header||YES

[RETURN|TYPE|VALUES|COMMENT]
RES1|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|NULL

[EXAMPLE]
!!WS default port =80;
!!WSS default port =443;

ws=HTTP_WSC("Server"); !!open on server default port;
ws=HTTP_WSC("ws:Server"); !!open on server default port;
ws=HTTP_WSC("ws:Server:5001"); !!open on server at port 5001;
ws=HTTP_WSC("wss:Server:5001"); !!open on server secure at port 5001;
ws=HTTP_WSC("wss:Server"); !!open on server at default secure port ;
>


[*] (fnc) HTTP_WSC_SND : Send a Symb or a BUFF
Related: HTTP_WSC, HTTP_WSC_RCV,  HTTP_WSC_INQ

< 1.HTTP_WSC_SND 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WS|PTR||PTR of WSC||
MSG|symb||a symb or PTR to a buffer||

[RETURN|TYPE|VALUES|COMMENT]
RES1|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|NULL

[EXAMPLE]
msg="Ciao";

rs=HTTP_WSC_SND(ws,msg);

buf=BUF_NEW(4,£U8);
buf=buf_symb(buf,1,4,"Ciao",£A);
rs=HTTP_WSC_SND(ws,buf);
>


[*] (fnc) HTTP_WSC_INQ : Inquire WS status
Related: HTTP_WSC, HTTP_WSC_RCV

< 1.HTTP_WSC_INQ 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WS|PTR||PTR of WSC||
TMO|NV||Time out   ms|0|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
rs=HTTP_WSC_INQ(ws);

#if(IsNULL(rs)); TRASH(ws); !!perhaps try to reopen; #end;
>


[*] (fnc) HTTP_WSC_RCV : Send a Symb or a BUFF
Related: HTTP_WSC, HTTP_WSC_SND, HTTP_WSC_INQ

< 1.HTTP_WSC_RCV - USE: Receive

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WS|PTR||PTR of WSC||
TMO|NV||Time out ms|500|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|NULL

[EXAMPLE]
rs=HTTP_WSC_RCV(ws);

#if(PTRTYP(rs)== £BUF);

   !!rs is a Buffer;

#else; 

   !!rs is a Symbol;

#end;
>


< 2.HTTP_WSC_RCV - USE: Receive in a buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WS|PTR||PTR of WSC||
TMO|NV||Time out ms|500|YES
BUF|PTR||PTR to a buffer||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES1|symb|NULL

[EXAMPLE]
!! Wait for buf size byte or time out expired;
rs=HTTP_WSC_RCV(ws, NULL, buf);
>


[*] (fnc) WUI_OPN : Open a WUI

< 1.WUI_OPN 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WUI_ITF|symb||Name of a .pkw file||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR
>


[*] (fnc) WUI_LOD : load  a new .pkw file

< 1.WUI_LOD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WUI|PTR||Valid  WUI ptr||
WUI_ITF|symb||Name of a .pkw file||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) WUI_SET : Depending from the WHT par set the TRIG or the address of the static Web

< 1.WUI_SET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WUI|PTR||Valid  WUI ptr||
WHT|symb|£TRG_HTML; £TRG_SYM;£TRG_INC;
£TRG_CTM;£STC||HTML|
PTR|NV||Pointer to TRIG or  address of static WEB||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
For INC : "TRG_WUI, TRG_PAGE, TRG_LANG, TRG_XTREE, TRG_XITM, TRG_XTYP, TRG_ID, TRG_ATT,TRG_TYP, TRG_VAL, TRG_PAR, TRG_FROM, TRG_R_XITM, TRG_R_ID, TRG_R_NUM, TRG_KB1, TRG_CTM, TRG_RES, TRG_RES_VAL "

For HTML : "TRG_WUI, TRG_PAGE, TRG_LANG, TRG_XTREE,  TRG_XITM, TRG_XTYP, TRG_ID, TRG_ATT, TRG_TYP, TRG_VAL, TRG_PAR, TRG_FROM, TRG_KB1, TRG_CTM,  TRG_RES, TRG_RES_VAL "

For SYM : "TRG_WUI, TRG_PAGE, TRG_LANG,  TRG_TYP, TRG_VAL, TRG_PAR,  TRG_KB1, TRG_CTM, TRG_RES, TRG_RES_VAL "

For CTM : "TRG_WUI, TRG_PAGE, TRG_LANG, TRG_XTREE,  TRG_XITM, TRG_XTYP, TRG_ID, TRG_ATT, TRG_TYP, TRG_VAL, TRG_PAR, TRG_FROM, TRG_KB1, TRG_CTM,  TRG_RES, TRG_RES_VAL "
In TRG_ID the content of “data-pwk-ctm-id” attribute and in TRG_ATT the attribute name or if TRG_XTYP=TEXT the text content.

TRIG SET parameters 
=================
TRG_WUI       PTR       The Wui
TRG_PAGE         symb      The html page name
TRG_LANG         symb      The language ID  (from GUI_HTML)
TRG_XTREE       PTR        The Tree of XITM
TRG_XITM       nv       Tree item
TRG_XTYP       symb       TEXT,ATTR,CDTA,ELEM,CMNT
TRG_ID              symb       HTML id or data-pwk-ctm-id (for CTM)       
TRG_ATT            symb      if XTYP=ATTR the attribute name
TRG_TYP       symb        £, RES,  PKG, REL, SYM, EMB or HTML tag
TRG_VAL       symb       value of Item
TRG_PAR       symb       Parameter set in WUI_HTML
TRG_KB1       PTR       Usually the KB1 of  WEB trig  (from GUI_HTML)

TRG_FROM       symb       £HTML, £REF, £REF_ADD, £RPT, RPT_ADD
TRG_R_XITM       nv       The replicated  REF or RPT elm
TRG_R_ID          symb      The ID of the _REF_ or  _RPT_
TRG_R_NUM       nv       The ordinal number of REF RPT replication (times REF parameters)


TRIG GET parameters
=================
TRG_RES        nv       0= translation are not  performed, 1=performed 
TRG_RES_VAL       symb     Value (if £REF or £REP) is the new value of the times parameter
>


[*] (fnc) WUI_HTML : load  a new .pkw file
Related: WUI_CPTH

< 1.WUI_HTML 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WUI|PTR||Valid  WUI ptr||
PAGE|symb||ID of the HTML page in wui||
KB1|PTR||Received in  TRG_KB1||YES
LANG|symb||Received in TRG_LANG||YES
PAR|symb||For TRG||YES
CTM|PTR||ConTent Manager PTR||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) WUI_CPTH : Symbolic path translation
Related: WUI_SPTH
Remark: WUI_HTML can insert Symbolic Path to item , use this to get the real pth

< 1.WUI_CPTH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WUI|PTR||Valid  WUI ptr||
PTH|symb||Path||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
Virtual System Path or User defined path are substituted (the real path +all the left side)

_PWK_PKG_ Path of Package
_PWK_REL_ Path relative to actual program path
_PWK_STC_ Static web address
>


[*] (fnc) WUI_SPTH : Set Path for Symbolic path translation
Related: WUI_CPTH

< 1.WUI_SPTH 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WUI|PTR||Valid  WUI ptr||
VPTH|symb||Virtual Path||
RPTH|symb||Real Path||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
Predefined System Path:
_PWK_PKG_ Path of Package
_PWK_REL_ Path relative to actual program path
_PWK_STC_ Static web address
>


[*] (fnc) MTH_PLY : Polynomial
Remark: TBL of values should have X, Y column name

< 1.MTH_PLY - USE: Creation or recompute from a TBL of values

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PLY|PTR||If null a new poly is created||
TBL|PTR||Table with X,Y values (if null) old values are used||
ORD|NV||POLYnomial Order (<10)||
XCOLNAM|symb||Name of X column|£X|YES
YCOLNAM|symb||Name of Y column|£Y|YES
EL_NUM|NV||Number of elements|TBL|YES
EL_FIRST|NV||Start element 1bsd|1|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
ply=MTH_PLY( £NULL, tbl, 5) ; !!  a ply is created and computed with order=5
MTH_PLY( ply, £NULL, 7) ; !!  Recomputed  with order=7
MTH_PLY( ply, tbl1, 6) ; !!  new values computed with order=6
>


< 2.MTH_PLY - USE: Creation  from a TBL of coef

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
TBL|PTR||TBL of Coef||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
tbl=MTH_PLY(oldPly,£COEFTBL); !! get the tbl of coef;

newPly=MTH_PLY(tbl); !!Create a new ply;
>


< 3.MTH_PLY - USE: Get values

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PLY|PTR||valid pTR||
WHAT|NNV|£X;£Y|Value to compute||
VAL|NV||y or x value||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
x=MTH_PLY( PLY, £X, y) ; 
y=MTH_PLY( PLY, £Y, x) ;
>


< 4.MTH_PLY - USE: Get TBL of Coef

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PLY|PTR||valid pTR||
WHAT|NNV|£COEFTBL|Value to compute||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
tbl=MTH_PLY( PLY, £COEFTBL); 

!! the tbl has two columns (£X,£X) and ORDER+1 rows:
>


< 5.MTH_PLY - USE: Get poly coef

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PLY|PTR||valid pTR||
WHAT|NNV|£COEFX;£COEFY|Value to get||
VAL|NV||ORDER of coef 0bsd  (!!!)||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
cx=MTH_PLY( PLY, £COEFX, 1) ; 
cy=MTH_PLY( PLY, £COEFY, 1) ; 

The number of Coef are order+1 so there is coef 0
>


[*] (fnc) MTH_FLTR : Filter NV performing a mobile average on DEEP values

< 1.MTH_FLTR - USE: Creation

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
CMD|symb|£NEW|||
DEEP|NV||number of values|7|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 2.MTH_FLTR - USE: Change the deep

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FLTR|PTR||FLTR pointer||
WHAT|symb|£NV|||
DEEP|NV||||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 3.MTH_FLTR - USE: Set a new values  and get the average

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FLTR|PTR||FLTR pointer||
WHAT|symb|£SET|||
VAL|NV||The new value to add||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) MTH_CNV : MATH conversion

< 1.MTH_CNV - USE: Creation

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
VAL|NV||||
TYPE|symb|£RAD(To radiant);£DEG(To degree)|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


[*] (fnc) MTH_REG : it is an advanced PID (proportional, integrative, derivative) for control
Remark: *** DO NOT USE *** work in progress

< 1.MTH_REG - USE: Creation

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
CMD|symb|£NEW|||
TYPE|NV|£GoAndStay;£GoAndReset||£GoAndStay;|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL
>


< 2.MTH_REG - USE: Set Parameters

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
REG|PTR||to REG||
WHAT|symb|£MAXVAL;£P(proportional);£i(Integrative);£D(Derivative);£ZoneD;£TMO;£ZE|||
VAL|NV||||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|PTR

[OnError|TYPE|VALUES|COMMENT]
ERR|symb|NULL

[EXAMPLE]
MAXVAL : max scale value;
P : %(0.0-1.0) proportional correction (of error)
I : (0.0-1.0) integration value (minimum values to get an effect)
D : %(0.0-1.0) derivative correction to use (in Derivative ZONE)
ZoneD: range or error  %(0.0-1.0) below which activate  the derivative correction
TMO: in ms max time to wait if a correction has not taken effect
ZE: delta +- from consider error like Zero
>


[*] (fnc) HIO_GPIOnew : Open a GPIO device (Default device)

< 1.HIO_GPIOnew 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HIO_GPIOset : Set parameters of a GPIO device
Remark: NULL value= not change; Empty (£) =reset

< 1.HIO_GPIOset 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GPIO|PTR||A PTR to a GPIO device pin||
PIN|NV||The pin number||
MODE|symbol|0(input);1(output);2(inputPullUp);3(inputPullDown);4(outputOpenDrain);5(outputOpenDrainPullUp);6(outputOpenSource);7(outputOpenSourcePullDown)|The open mode, input||YES
TRIG|PTR||PTR to a trig||YES
TRIG_WAIT|NV||Isteresys time||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
The trig set these parameters:
trg_pin = the pin number
trg_val = the pin value
trg_edge = the edge value
>


[*] (fnc) HIO_GPIO : INPUT or Output on a pin
Remark: if the pin is not configured, the first operation set it to with the default mode (0 or 1)

< 1.HIO_GPIO 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GPIO|PTR||A PTR to a GPIO device pin||
PIN|NV||The pin number||
OUT_VALUE|symbol|0;£LOW(0);1;£HIGH(1)|if NUL an imput operation is performed||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HIO_GPIOpwm : Return a PTR to a PWM manager on a pin

< 1.HIO_GPIOpwm 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GPIO|PTR||A PTR to a GPIO||
PIN|NV||The pin number||
CYCLE|NV||in micro the cycle||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HIO_GPIOpulse : Raise a pulse on a pin

< 1.HIO_GPIOpulse 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
GPIO|PTR||A PTR to a GPIO||
PIN|NV||The pin number||
VALUE|NV|1;0|in micro the cycle||
MICRO|NV||Duration in micro||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HIO_PWM : Operation on a PWM

< 1.HIO_PWM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
PWM|PTR||A PTR to a PWM||
CMD|symbol|£START;£STOP;£SET|||
DUTY|NV||in micro the duty part of the cycle||YES
CICLE|NV||in micro the cicle||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HIO_I2Cnew : Open an I2C device
Related: SPI, UART

< 1.HIO_I2Cnew 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|symbol|£I2C;£I2C1;£I2C2|The bus name||
UNIT_ADR|NV||The unit address||
UNIT_ID|symbol||The unit ID||YES
BUS_SPEED|symbol|0(Standard);1(fast)|Bust speed||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DEVICE are renamed according to board type: 

PI 2 /3        I2C1
DRAGONBOARD I2C0, I2C1
MINNOWBOARD I2C5
>


[*] (fnc) HIO_I2C : read and write on i2C device to and from a BUF or directly
Related: BUF

< 1.HIO_I2C - USE: R/W From buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||I2C device PTR||
ACTION|symbol|£READ;£WRITE;£WriteRead|WriteRead makes a read with Restart instead of stop||
BUFFER|PTR||A BUF PTR||
BYTES|NV||Number of bytes to read or write||YES
REGISTER|NV||ONLY FOR £READ and £WriteRead Register Number (write to dvc before the read)||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=BUF_NEW(2,£U8);
BUF_VAL(buf,1,0x5);
BUF_VAL(buf,2,0x8);
HIO_I2C( dvc,£WRITE, buf,1); !!write only 0x5;
HIO_I2C( dvc,£WRITE, buf); !!write all the buffer 0x5, 0x8 ;
HIO_I2C( dvc,£READ, buf,1); !! read 1 byte;
HIO_I2C( dvc,£READ, buf); !! read all the buffer :2 bytes;
HIO_I2C( dvc,£READ, buf,2,0xA); !! writes 0xA (Register)and read all the buffer :2 bytes (Write part Accept multiple bytes like W Direct)

TRASH(buf);
>


< 2.HIO_I2C - USE: W Direct

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||I2C device PTR||
ACTION|symbol|£WRITE||£WRITE|
BUFFER|PTR|NULL||NULL|YES
BYTES|slis||symbol to write||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
HIO_I2C( dvc,£WRITE, NULL,0x5,0x8); !!write  0x5, 0x8;
>


< 3.HIO_I2C - USE: R Directly

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||I2C device PTR||
ACTION|symbol|£READ||£READ|
BUFFER|PTR|NULL||NULL|YES
BYTES|NV||number of byte to read (1,2,3,4)|1|YES
REGISTER|NV||Register Number (written to dvc before the read )||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
s=HIO_I2C( dvc,£READ, NULL,1); !!read 1 byte (maximum 4) ;
>


[*] (fnc) HIO_SPInew : Open an SPIdevice
Related: I2C, UART

< 1.HIO_SPInew 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|symbol|£SPI;£SPI1;£SPI2|The bus name||
LINE|NV||Selection line||
UNIT_ID|symbol||The unit ID||YES
CLOCK_FRQ|NV||clock Frequecy Hz||YES
BIT_Lenght|NV||||YES
MODE|NV|0(CPOL 0 - CPHA 0);
1(CPOL 0 - CPHA 1);
2(CPOL 1 - CPHA 0);
3(CPOL 1 - CPHA 1);|Communication Mode, Clock Polarity and Clock Phase||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DEVICE are renamed according to board type:

PI 2 /3        SPI0, SPI1
DRAGONBOARD SPI0
MINNOWBOARD SPI0
>


[*] (fnc) HIO_SPI : read and write on SPI device to and from a BUF or directly
Related: BUF

< 1.HIO_SPI - USE: R/W From buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||SPI device PTR||
ACTION|symbol|£READ;£WRITE|||
BUFFER|PTR||A BUF PTR||
BYTES|NV||Number of bytes to read or write||YES
REGISTER|||ONLY FOR £READ
Register Number (write to dvc before the read)||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=BUF_NEW(2,£U8);
BUF_VAL(buf,1,0x5);
BUF_VAL(buf,2,0x8);
HIO_SPI( dvc,£WRITE, buf,1); !!write only 0x5;
HIO_SPI( dvc,£WRITE, buf); !!write all the buffer 0x5, 0x8 ;

HIO_SPI( dvc,£READ, buf,1); !! read 1 byte;
HIO_SPI( dvc,£READ, buf); !! read all the buffer :2 bytes;
TRASH(buf);
>


< 2.HIO_SPI - USE: W Directly

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||SPI device PTR||
ACTION|symbol|£WRITE||£WRITE|
BUFFER|PTR|NULL||NULL|YES
BYTES|slis||symbol to write||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
HIO_SPI( dvc,£WRITE, NULL,0x5,0x8); !!write  0x5, 0x8;
>


< 3.HIO_SPI - USE: R Directly

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||SPI device PTR||
ACTION|symbol|£READ||£READ|
BUFFER|PTR|NULL||NULL|YES
BYTES|NV||number of byte to read (1,2,3,4)|1|YES
REGISTER|NV||Register Number (written to dvc before the read )||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
s=HIO_SPI( dvc,£READ, NULL,1); !!read 1 byte (maximum 4) ;
>


[*] (fnc) HIO_UARTnew : Open an UART device
Related: SPI, I2C

< 1.HIO_UARTnew 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|symbol|£UART;£UART1;£UART1|The bus name||
UNIT_ID|symbol||The unit ID||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DEVICE are renamed according to board type:
PI 2 /3               UART0
DRAGONBOARD UART0,UART1
MINNOWBOARD UART1,UART2
>


[*] (fnc) HIO_UARTset : Set communication parameter

< 1.HIO_UARTset - USE: R/W From buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||UART device PTR||
BAUD|NV||Baud rate||YES
DATAbit|NV||number of data bit||YES
STOPbit|symb|£1;£1.5;£2|stop bit||YES
PARITY|symb|£NONE;£ODD;£EVEN;£MARK;£SPACE|||YES
HANDshake|symb|£NONE;£RTS;£XonXoff;£RtsXonXof|||YES
TXtmo|NV||TX tmo in ms||YES
RXtmo|NV||RX tmo in ms||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) HIO_UART : read and write on UART device to and from a BUF or directly
Related: BUF

< 1.HIO_UART - USE: R/W From buffer

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||UART device PTR||
ACTION|symbol|£READ;£WRITE|||
BUFFER|PTR||A BUF PTR||
BYTES|NV||Number of bytes to read or write||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=BUF_NEW(2,£U8);
BUF_VAL(buf,1,0x5);
BUF_VAL(buf,2,0x8);
HIO_UART( dvc,£WRITE, buf,1); !!write only 0x5;
HIO_UART( dvc,£WRITE, buf); !!write all the buffer 0x5, 0x8 ;

HIO_UART( dvc,£READ, buf,1); !! read 1 byte;
HIO_UART( dvc,£READ, buf); !! read all the buffer :2 bytes;
TRASH(buf);
>


< 2.HIO_UART - USE: W Directly

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||UART device PTR||
ACTION|symbol|£WRITE||£WRITE|
BUFFER|PTR|NULL||NULL|YES
BYTES|slis||symbol to write||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
HIO_I2C( dvc,£WRITE, NULL,0x5,0x8); !!write  0x5, 0x8;
>


< 3.HIO_UART - USE: R Directly

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DEVICE|PTR||UART device PTR||
ACTION|symbol|£READ||£READ|
BUFFER|PTR|NULL||NULL|YES
BYTES|NV||number of byte to read (1,2,3,4)|1|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
s=HIO_I2C( dvc,£READ, NULL,1); !!read 1 byte (maximum 4) ;
>


[*] (fnc) OPC_NEW : Create an OPC server or Client

< 1.OPC_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WHAT|symb|£CLI;£SRV|||
PAR|symb||For SRV the TCP port||YES
CERT|symb||Certificate .der file name||YES
KEY|symb||KEY .der file name||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) OPC_SRV : Start or Stop an OPC SRV

< 1.OPC_SRV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£START;£STOP|||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) OPC_CLI : Open, Close or Set Parameters for an OPC Client connection

< 1.OPC_CLI - USE: Open / Close

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£OPEN;£CLOSE|||
EPS|symb||End Point String for OPEN||YES
USER|symb||||YES
PASSWORD|symb||||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
opc_ptr=OPC_CLI(opc_ptr, £OPEN, “opc.tcp://localhost:4840”);
>


< 2.OPC_CLI - USE: Set Parameters

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£SETPAR|||
TRIG|symb||PTR to connection Trig||YES
TMITER|NV||Iteration time (ms)||YES
TMITERSleep|NV||Sleep Time between iteration (ms)||YES
TMO|NV||Operation TimeOut||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TRIG parameters are :  OPC_PTR, CLI_STATUS, CLI_SECURE, CLI_SESSION

CLI_STATUS: many

In PWK OPC implementation a thread takes care of asynchronous communication, the iteration time is the Working time for communications with the Server, the Itersleep is the pause between WT.
>


< 3.OPC_CLI - USE: Return the Last Status

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£LERR|||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


< 4.OPC_CLI - USE: Set Secure policy

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£SECURITY|||
MODE|NV||0-3 (see below)||YES
URI|symb||see (see below)||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
MODE:
UA_MESSAGESECURITYMODE_INVALID = 0,
UA_MESSAGESECURITYMODE_NONE = 1,
UA_MESSAGESECURITYMODE_SIGN = 2,
UA_MESSAGESECURITYMODE_SIGNANDENCRYPT = 3

URI:
http://opcfoundation.org/UA/SecurityPolicy#None
http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15
http://opcfoundation.org/UA/SecurityPolicy#Basic256
http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256
http://opcfoundation.org/UA/SecurityPolicy#Aes128_Sha256_RsaOaep
>


< 5.OPC_CLI - USE: Set Application URI

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£CERTIFICATE|||
APPURI|symb||Certificate Application Uri||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
Looking into the certificate search the URL "urn:.." into APPURI
>


< 6.OPC_CLI - USE: Enable/Disable the log

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£LOG|||
ACTION||£YES;£NO|||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
The log is saved in C:\PWK-TMP\EXECLOG.txt
>


[*] (fnc) OPC_RD : Read
Related: OPC_GET, OPC_WR
Remark: This function return a PTR (ToDel) that contains the read value. This because can return a plain symbol or a TBL or a BUF

< 1.OPC_RD 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
WHAT|symb|£VALUE;
£DISPLAYNAME;
£DESCRIPTION;
£INVERSENAME;
£BROWSENAME;
£DATATYPE;
£NODEID;
£BROWSE;£SUBID(SubscriptioId)|||
NODEID|symb||Name space + Name id "n;id" or "ns:n ; s=id"||YES
AS|symb|£VAL;£TBL;£BUF||£VAL|YES

[RETURN|TYPE|VALUES|COMMENT]
SUBID|NV|
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
rs=OPC_RD(opc_ptr,£VALUE,”2;.recipe”);
recipe=OPC_GET(rs);
>


[*] (fnc) OPC_GET : Get the  value or the kind, or the type of a result of an OPC function
Related: OPC_RD

< 1.OPC_GET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
WHAT|symb|£VAl;£KND(kind);£TYP|KND could be VAL,TBL,BUF
TYP is the type (BO,U8 ..)|£VAL|YES

[RETURN|TYPE|VALUES|COMMENT]
KND|symb|
TYP|symb|
VAL|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
rs=OPC_RD(opc_ptr,£VAL,”2;.recipe”);

#while(1); !!like a switch;

       #if(OPC_GET(rs,£KND)==£val);
       recipe=OPC_GET(rs);
       #break;#end;

       #if(OPC_GET(rs, £KND)==£TBL);
       recTbl=OPC_GET(rs);
       !! use recTbl then;
       TRASH(recTbl);
       #break;#end;

       #if(OPC_GET(rs, £KND)==£BUF);
       recBuf=OPC_GET(rs);
       !! use recBuf then;
       TRASH(recBuf);
       #break;#end;

#break;  
#end;
 
TRASH(rs);
!! NOTE: if you don't read £val, you only need to trash the result NOT the contained VAL; DTT=DateTime (UNIX time)
>


[*] (fnc) OPC_WR : Write
Related: OPC_RD

< 1.OPC_WR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
NODEID|symb||Name space + Name id "n;id" or "ns:n ; s=id"||
VALUE|symb||||
WHAT|symb|£VALUE||£VALUE|YES
KND|symb|£VAL;£TBL;£BUF||£VAL|YES
TYP|symb|£BO;£U8;£I8;£U16;£I16;£U32;£I32;£I64;£U64;£F32;£F64;£STR;£DTT;£GID|If N.D. it is to read before the write||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
rs=OPC_WD(opc_ptr,”2;.recipe”,”MyRecipe”);
>


[*] (fnc) OPC_MNT : Monitor an OPC Item for ValueAttribute change
Related: OPC_RD

< 1.OPC_MNT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
NODEID|symb||Name space + Name id "n;id" or "ns:n ; s=id"||
TRIG|PTR||TRIG for data change||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
trg=TRIG(“\OPC\TRG_MNT”,”OPC_PTR, XUA_VAL,STATUS,TS_SERVER,TS_SOURCE”);
rs=OPC_MNT(opc_ptr,”2;.recipe”,”MyRecipe”,trg);

The XUA_VAL and the inner TBL or BUF PTR should be NEVER deleted because are deleted by the trig on return, if you want to use it in other side of the program you have to clone.
>


[*] (fnc) OPC_EVT : Register for OPC events or Refresh
Related: OPC_MNT

< 1.OPC_EVT - USE: Set Event

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
NODEID|symb||Name space + Name id "n;id" or "ns:n ; s=id"||
ATTID|NV||Attribute id for the event||
TRIG|PTR||PTR to TRIG for event||
CND|PTR||PTR to Condition Table||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
trg_ev=TRIG(£TRIG_EV,"TBL_XUA_VAL");

tbl=TBL_NEW(NULL,3,NULL,NULL,"TypDefId;AttId;BrwPth");

tbl_itm(tbl,1,1,"0;2782"); !!! UA_NS0ID_CONDITIONTYPE;
tbl_itm(tbl,2,1,"1"); !!! UA_ATTRIBUTEID_NODEID;

tbl_itm(tbl,1,2,"0;2041"); !!! UA_NS0ID_BASEEVENTTYPE;
tbl_itm(tbl,2,2,"13"); !!! UA_ATTRIBUTEID_VALUE;
tbl_itm(tbl,3,2,"0;Message"); !!! UA_TYPES_QUALIFIEDNAME;

tbl_itm(tbl,1,3,"0;2041"); !!! UA_NS0ID_BASEEVENTTYPE;
tbl_itm(tbl,2,3,"13"); !!! UA_ATTRIBUTEID_VALUE;
tbl_itm(tbl,3,3,"15;HelpText"); !!! UA_TYPES_QUALIFIEDNAME;
;

opc_evt(opc,"ns=16;s=DiagnosisLogbook",12,trg_ev,tbl); !!12 is the attId for UA_ATTRIBUTEID_EVENTNOTIFIER;

The trig is called with a TBL of XUA_VAL (one for each condition) organized for column and, as for MNT, don't delete any of this elements.
>


< 2.OPC_EVT - USE: Refresh event

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
CMD|symb|£REFRESH|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
rs=OPC_EVT(opc_ptr,”£REFRESH);
>


[*] (fnc) OPC_CALL : Call an OPC Method
Related: OPC_RD

< 1.OPC_CALL 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
OPC|symb||OPC PTR||
OBJID|symb||Object id||
MTHDID|symb||Method id||
INPUTPAR|PTR||TBL of par COL(par, parTyp)||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
tbl=tbl_new(2,1);
tbl_itm(tbl,1, 0, OPC_RD(opc_ptr,£SUBID));
tbl_itm(tbl,2,0, £U32);

!!UA_NS0ID_CONDITIONTYPE = 2782;
!!UA_NS0ID_CONDITIONTYPE_CONDITIONREFRESH = 3875;

tbl=OPC_CALL(opc_ptr, “0;2782”,”0; 3875”, tbl); 

i=0;
in=TBL_INF(tbl,£ROW);

#while(i=i+1; i<in);
TRASH(tbl_itm(tbl,1,i);
#end;
TRASH(tbl);
>


[*] (fnc) OPC_DISCOVER : Discover end point
Related: OPC_RD

< 1.OPC_DISCOVER 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WHAT|symb|£ENDPOINT|||
QS|symb||Query String||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
res=OPC_DISCOVER( £Endpoint, "opc.tcp://192.168.2.17:4840");

chatput(£DISCOVER..tbl_exp(res));
TRASH(res)
>


[*] (fnc) COM_NEW : Open a  Serial COM

< 1.COM_NEW 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM_NAME|symb||COM1, COM2, ..||
PARAMETERS|symb||See below for a list||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
com=COM_NEW(£COM3, “baud=9600 data=8 parity=n stop=2)

[baud={11|110|15|150|30|300|60|600|12|1200|24|2400|48|4800|96|9600|19|19200}]
[parity={n|e|o|m|s}]       "none", "even", "odd", "mark", and "space".
[data={5|6|7|8}]
[stop={1|1.5|2}]
[to={on|off}]       Specifies whether infinite time-out processing is on or off. The default is off.
[xon={on|off}]       Specifies whether the xon or xoff protocol for data-flow control is on or off.
[odsr={on|off}]       Specifies whether output handshaking that uses the Data Set Ready (DSR) circuit is on or off.
[octs={on|off}]       Specifies whether output handshaking that uses the Clear To Send (CTS) circuit is on or off.
[dtr={on|off|hs}]       Specifies whether the Data Terminal Ready (DTR) circuit is on or off or set to handshake.
[rts={on|off|hs|tg}]       Specifies whether the Request To Send (RTS) circuit is set to on, off, handshake, or toggle.
[idsr={on|off}]              Specifies whether the DSR circuit sensitivity is on or off.
The "baud" substring can be any of the values listed, which are in pairs. 
The two-digit values are the first two digits of the associated values that they represent. 
For example, 11 represents 110 baud, 19 represents 19,200 baud.
The "parity" substring indicates how the parity bit is used to detect transmission errors.
>


[*] (fnc) COM_SET : Change COM setting as well default timeOut values
Related: COM_NEW
Remark: Usually there is not need to change

< 1.COM_SET 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||||
PARAMETERS|symb||See CON_NEW||YES
RIT|NV||50 initial values||YES
RTTC|NV||50||YES
RTTM|NV||10||YES
WTTC|NV||50||YES
WTTM|NV||10||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
All values are in milliseconds.
RIT:       ReadIntervalTimeout Specifies the maximum time interval between arrival of two bytes. If the arrival time exceeds these limits the ReadFile() function returns.

RTTC:       ReadTotalTimeoutConstant is used to calculate the total time-out period for read operations. For each read operation, this value is added to the product of the ReadTotalTimeoutMultiplier member and the requested number of bytes.

RTTM:       ReadTotalTimeoutMultiplier is used to calculate the total time-out period for read operations. For each read operation, this value is multiplied by the requested number of bytes to be read.
       
WTTC:       WriteTotalTimeoutConstant similar to ReadTotalTimeoutConstant but for write operation.

WTTM:       WriteTotalTimeoutMultiplier similar to ReadTotalTimeoutMultiplier but for write operation.
>


[*] (fnc) COM_RCV : Receive data in a buffer
Related: COM_WAIT

< 1.COM_RCV 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||||
BUFFER|PTR||||
BUFFER_INDEX|NV||Start of the buffer 1bsd|1|YES
SIZE|NV||# of byte to wait|0|YES
TMO|NV||Ms time out||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|

[EXAMPLE]
This function return when:
if SIZE when all byte are arrived,
when the buffer is full,
when TMO is expired.
>


[*] (fnc) COM_WAIT : Wait for data
Related: COM_WAIT

< 1.COM_WAIT 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||||
BUFFER_OR_STOP|PTR||Use £STOP to end||
BUFFER_INDEX|NV||Start of the buffer 1bsd|1|YES
TMO|NV||Ms time out used after the first byte||YES
SIZE|NV||# of byte to wait||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|

[EXAMPLE]
This function return when:
when the buffer is full or size is reached,
when TMO is expired, this time out start after the first received byte.
when in another THREAD the function is called with £STOP
>


[*] (fnc) COM_SND : SEND data
Related: COM_WAIT

< 1.COM_SND 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||PTR||
BUFFER|PTR||PTR||
BUFFER_INDEX|NV||1bsd||YES
SIZE|NV||In BYTE if ND buffer size is used||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|
>


[*] (fnc) COM_FNC : Execute Escape Com function

< 1.COM_FNC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||PTR||
FUNCTION|symb|£SETXOFF;
£SETXON;
£SETRTS;£CLRRTS;£SETDTR;£CLRDTR;£SETBREAK;£CLRBREAK|||

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|
>


[*] (fnc) COM_GMS : Get Modem status

< 1.COM_GMS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||PTR||
WHAT|Symb|£CTS;£DSR;£RING;£CD|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1/0
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|

[EXAMPLE]
COM_GMS(P,£CTS) >>> 1/0
COM_GMS(P) >>> “CTS,CD”
>


[*] (fnc) COM_ERR : Get  Errors

< 1.COM_ERR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||PTR||
WHAT|Symb|£DND;£IOE;£OOP;£PTO;£MODE;£BREAK;£FRAME;£RXOVER;£TXFULL;£OVERRUN;RXPARITY|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1/0
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|
>


[*] (fnc) COM_STS : Get  COM status

< 1.COM_STS 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COM|PTR||PTR||
WHAT|Symb|£SNDQ(#char to send);
£RCVQ(#char to read);£CTS_hold;£DSR_hold;£CD_hold;XOFF_hold;XOFF_sent;£EOF;£TXIM|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|1/0
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
RES|NV|
>


[*] (fnc) OSI_DVC : Get  TBL of host devices

< 1.OSI_DVC 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
COLUMN_NAME|symb||Column name||YES
COLUMN_VALUE|symb||Column value||YES
LEVEL|NV||Device level||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
If Column Name and Column Value are defined they act as filter;
If LEVEL is defined is used as filter.
Column names are:

DEVICEDESC, HARDWAREID, COMPATIBLEIDS, SERVICE, CLASS, CLASSGUID, DRIVER, CONFIGFLAGS, MFG, FRIENDLYNAME, LOCATION_INFORMATION, PHYSICAL_DEVICE_OBJECT_NAME, CAPABILITIES, UI_NUMBER, UPPERFILTERS, LOWERFILTERS, BUSTYPEGUID, LEGACYBUSTYPE, BUSNUMBER, ENUMERATOR_NAME, DEVTYPE, EXCLUSIVE, CHARACTERISTICS, ADDRESS, UI_NUMBER_DESC_FORMAT, DEVICE_POWER_DATA, REMOVAL_POLICY, REMOVAL_POLICY_HW_DEFAULT, REMOVAL_POLICY_OVERRIDE, INSTALL_STATE, LOCATION_PATHS, BASE_CONTAINERID
>


[*] (fnc) DRW_NEW : Create or load a draw
Remark: A 32 bit ARGB bitmap

< 1.DRW_NEW - USE: New from size

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
X-SIZE|NV||Wide in pixel||
Y-SIZE|NV||Height in pixel||
ClrBKG|NV||Back Ground color (white)|0xFFFFFFFF|YES
ClrFRG|NV||Fore Ground color (black)|0xFF000000|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
bmp=DRW_NEW(800,600);
>


< 2.DRW_NEW - USE: Load from a file

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb||Fine name||
NotUsed|symb|NULL|||YES
ClrBKG|NV||Back Ground color (white)|0xFFFFFFFF|YES
ClrFRG|NV||Fore Ground color (black)|0xFF000000|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
!!the file extension should be: .bmp, .png, .jpg, .jpeg;
!! for other format like .heic be sure to have the codec on your OS;
bmp=DRW_NEW(”image.png”);
>


< 3.DRW_NEW - USE: Load from a file BUF

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
FILENAME|symb|£FILEBUF|||
BUF_PTR|symb||BUF containing the image (.type)||
ClrBKG|NV||Back Ground color (white)|0xFFFFFFFF|YES
ClrFRG|NV||Fore Ground color (black)|0xFF000000|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
!!the file should be: .bmp, .png, .jpg, .jpeg;
bmp=DRW_NEW(£FILEBUF, buf);
>


< 4.DRW_NEW - USE: From a BUF created with DRW_EXP or OCVMAT

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
WHAT|PTR||PTR to BUF or to OCVMAT||
NotUsed|NV||For OCV: 1=new, 0=linked|1|YES
ClrBKG|NV||Back Ground color (white)|0xFFFFFFFF|YES
ClrFRG|NV||Fore Ground color (black)|0xFF000000|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
buf=DRW_EXP(bmp,£BUF);
bmp=DRW_NEW(buf);

BUF format 32 bitarray:
- 0xBBBB0020 ; //key
- size X; //Column
- size Y; //Row
- data ...
>


[*] (fnc) DRW_CLN : Clone a DRW and optionally with a different size
Related: DRW_CPY

< 1.DRW_CLN - USE: New from size

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW to clone||
X-SIZE|NV||Wide in pixel||YES
Y-SIZE|NV||Height in pixel||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
oldDrw=DRW_NEW(800,600);

newDrw=DRW_CLN(oldDrw,400,300);
>


[*] (fnc) DRW_CPY : Copy a DRW in another
Related: DRW_CLN

< 1.DRW_CPY - USE: New from size

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW_DST|PTR||DRW destination||
DRW_SRC|PTR||DRW  to Copy||
X|NV||Position on dst 1bsd|1|YES
Y|NV||Position on dst 1bsd|1|YES
Xs|NV||Position on src 1bsd|1|YES
Ys|NV||Position on src 1bsd|1|YES
SizX|NV||wide|(src)|YES
SizY|NV||high|(src)|YES
CLR_SRC_IGNORE|NV||Color in source to ignore or £TRANSP||YES
CLR_DST|NV||Color in destination  to overwrite||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
oldDrw=DRW_NEW(800,600);

newDrw=DRW_CLN(oldDrw,400,300);
>


[*] (fnc) DRW_INF : Return the info
Related: DRW_STAT

< 1.DRW_INF - USE: New from size

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW t||
WHAT|symb|£szX;£szY;£szE;£TOT;£FRMT|Wide, heght, pixel sizze (byte), total size (byte); Format||

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) DRW_STAT : Return statistical info about colors in the image or a square inside the image
Related: DRW_INF
Remark: For each IDX value is reported the number  of occurence

< 1.DRW_STAT - USE: New from size

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW||
Xbeg|NV||||YES
Xend|NV||||YES
Ybeg|NV||||YES
Yend|NV||||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL(IDX,R,G,B,H,S,L,H2RGB); 
IDX is the value
R,G,B,H,S,L columns contain the number of occurience of that IDX

R,G,B IDX=0-255; H IDX = 0-360; S,L IDX = 0-100
H2RGB is the RGB hexadecimal value relative to the Hue using as S,L the mean values
of all pixel with that Hue IDX.
>


[*] (fnc) DRW_ROT : Rotate a Bitmap

< 1.DRW_ROT - USE: New from size

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW t||
ANGLE|NV||Degree||
ROT_X|NV||Rotation point X|middle|YES
ROT_Y|NV||Rotation point Y|middle|YES
ADAPT|NV||1=the BMP will be adapdet to contain all the BMP after the rotation|1|YES
BKG_FILL|NV||Fill the BMP with BKG_CLR|0|YES
BKG_CLR|NV||0xAARRGGBB|0|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|symb|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL
>


[*] (fnc) DRW_DRAW : Draw a bmp or an OCVMAT
Related: See GUI draw on IMAGE

< 1.DRW_DRAW - USE: Code

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW or OCVMAT PTR||
CODE|symb||||

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
DRAW COMMAND
Each parameter is separated by a semi colon. Command are separated by '#'.
In the following list [ ] indicate option parameter and (..) admitted values.

COLOR
The notation is 0xAARRGGBB
Special colour:
TRANSP : transparent
DEL           : Delete colour ,BackGround  color is used


COORD[:x1;y1;x2;y2]              //alone reset. Upper Left; bottom right
CLR[:color]                     //alone use default backColor

POINT:color; line; x1;y1;[ …;xn;yn]

LINE: color; line; x1;y1;x2;y2;[ …;xn;yn]


RANGE: color; line; fill(FALSE|TRUE|line);x1;y1min;y1max;x2;y2min;y2max

BOX:color; line; fill(TRUE|FALSE); x1;y1;x2;y2

ELLIIPSE:color; line; fill(TRUE|FALSE); xc1;yc1;xc2;yc2

SECTOR:color; line;  fill(TRUE|FALSE); xc1;yc1; xc2, yc2; startAngle; sizeAngle

- xc, yc = centers of elipse or sector
- startAngle = Clock wise degree int

TEXT:color; x1;y1; text;[ fontName;fontSize;fontUnit(POINT|PIXEL |MM) ; fontStyle(BOLD,ITALIC,UNDERLINE);angle]

GMODE:  {OVER | COPY} 
Use OVER to write text


FILL: x;y;clrChk;clrSet;op;dst;spc;w1;w2;w3

       op=0: change clrChk to clrSet for all the points connected to x,y
       op=1; set to clrSet all the point connected to x,y comprise in clrChk boundaries

       OPTIONAL       
       if dst (distance flt 0.0 – 1.0) is defined the vector distance D between clrChk        and actual clr is computed and used for comparison so:
       D < dst :  change clrChk to clrSet for all the points connected to x,y
       D > dst :  set to clrSet all the point connected to x,y comprise in 
                   clrChk boundaries

       spc: RGB | BGR | HSL       ; color space default RGB

       If spc=HSL: w1,w2,w3 with value float (0.0 – 1.0) are the weight of H,S,L
                     (default 1.0)

FILLC: x;y;clrChk;clrSet;clrCtr;op;dst;spc;w1;w2;w3

       op=0: change clrChk to clrSet for all the points connected to x,y
       op=1; set to clrSet all the point connected to x,y comprise in clrChk boundaries

       ClrCtr sign the contour.

       OPTIONAL       
       if dst (distance flt 0.0 – 1.0) is defined the vector distance D between clrChk        and actual clr is computed and used for comparison so:
       D < dst :  change clrChk to clrSet for all the points connected to x,y
       D > dst :  set to clrSet all the point connected to x,y comprise in 
                   clrChk boundaries

       spc: RGB | BGR | HSL       ; color space default RGB

       If spc=HSL: w1,w2,w3 with value float (0.0 – 1.0) are the weight of H,S,L
                     (default 1.0)

CONTOUR: clrChk;clrSet;op;dst;spc;w1;w2;w3

       if clrChk is 0, contour is defined by the dst between two near pixel.
  


CLRCHG: clrChk;clrSet;op;dst;spc;w1;w2;w3

       op=0: change all point equal to clrChk to clrSet
       op=1; change all point NOT equal to clrChk to clrSet

       OPTIONAL       
       if dst (distance flt 0.0 – 1.0) is defined the vector distance D between clrChk        and actual clr is computed and used for comparison so:
       D < dst :  change clrChk to clrSet for all the points connected to x,y
       D > dst :  set to clrSet all the point connected to x,y comprise in 
                   clrChk boundaries

       spc: RGB | BGR | HSL       ; color space default RGB

       If spc=HSL: w1,w2,w3 with value float (0.0 – 1.0) are the weight of H,S,L
                     (default 1.0)

RCOORD[:angle;x1;x2;]              //Rotate Coord alone reset
>


[*] (fnc) DRW_SAVE : Save on a file or on a BUF
Remark: A 32 bit ARGB bitmap

< 1.DRW_SAVE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW PTR||
FILENAME|symb||File name or £FILEBUF||
FILEEXT|symb||If £FILEBUF the file type||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
!!the file extension should be: .bmp, .png, .jpg, .jpeg - if not default to .png;
DRW_SAVE(bmp,”image.png”); !!save in file;
°buf=DRW_SAVE(bmp,£FILEBUF,”.png”); !!save in BUF;
>


[*] (fnc) DRW_PIX : Set or get PIXEL value
Related: DRW_DRAW
Remark: A 32 bit ARGB bitmap

< 1.DRW_PIX 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW PTR||
X|NV||X position||
Y|NV||Y position||
VAL|NV||PIXEL value for SET||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
!!X and Y are relative to COORD (see DRW_DRAW);
DRW_PIX(drw, 50,50, 0xFF00FF00); !!SET;
px=DRW_PIX(drw, 50,50); !! GET;
>


[*] (fnc) DRW_CONTOUR : Return the TBL (X,Y) of the contour Pixel
Related: DRW_DRAW

< 1.DRW_CONTOUR 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW PTR||
COLOR|NV||ARGB color to check|0|YES
LIMIT|NV||0.0 – 1.0 limit|0|YES
SPACE|symb|£RGB;£HSL|Colot space|RGB|YES
W1|NV||Weigth  for  R or H|1.0|YES
W2|NV||Weigth  for  G or S||YES
W2|NV||Weigth  for  B or L||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
If COLOR is defined is used to check the contour, else wise any value difference between two near pixel or above the limit if defined, set the contour pixel in the returned TBL(X,Y).
>


[*] (fnc) DRW_SHAPE : Detect Shape and segment of shape
Remark: If RETURN = £ALL the function operate as MRF

< 1.DRW_SHAPE 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW PTR||
COLOR|NV||ARGB Value||
ON_RET|symb|£SHP;£SEG;£ALL|Values to return|£SHP|YES
OP|NV|0;1|0=COLOR Is Backgroud 1=Foreground|0|YES
LIMIT|NV||0.0 – 1.0 limit|0|YES
SPACE|symb|£RGB;£HSL|Colot space|RGB|YES
W1|NV||Weigth  for  R or H 0.0 1.0|1.0|YES
W2|NV||Weigth  for  G or S|1,0|YES
W2|NV||Weigth  for  B or L|1,0|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
TBL_SHAPE(PIX;X1;Y1;X2;Y2) !!total pixel, bounding box
TBL_SEGMENT(shpJ;ROW;pxFst;pxLst)


Tbl_Shape=DRW_SHAPE(drv,0xFFFFFFFF,0,£ALL)->Tbl_Segment
>


[*] (fnc) DRW_EXP : Export the bmp
Related: DRW_NEW
Remark: A 32 bit ARGB bitmap

< 1.DRW_EXP 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW PTR||
TYPE|symb|£BUFDRW,£BUFCPY;£BUF|Export type|BUF|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
exp=DRW_EXP(bmp,£BUFDRW);
nbmp=DRW_NEW(exp);

!!BUFDRW return a buffer with: a prefix 0xBBBB0020; size X; size Y; Data
!!BUFCPY return a copy of the DRW DATA
!!BUF    return a CHUNK pointing to the drw data
>


[*] (fnc) DRW_STREAM : Stream the bitmap to a GUI IMAGE element
Related: DRW_NEW
Remark: A 32 bit ARGB bitmap

< 1.DRW_STREAM 

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
DRW|PTR||DRW PTR||
GUI|PTR||GUI PTR||
IMAGE|NV||$ADDRESS of an IMAGE||
ASYNC|NV||Flag|0|YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
res=DRW_STREAM(bmp,_PTR_@\Pag, $\PAG\IMG);
ASYNC: 0=sync; 1=async; >1= $ADR for notification (Nullyfy)
>


[*] (fnc) ARC_UNZIP : Unzip a Zipped archive
Related: ARC_DOZIP, ARC_INF

< 1.ARC_UNZIP - USE: Unzip

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ARCHIVE|symb||Archive name||
PATH|Symb||Unzip Directory|temporary|YES
FILE|slist||List of files to extract||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
°z=ARC_UNZIP(“test.zip”);
°z=ARC_UNZIP(“test.docx”,NULL,”word/document.xml”);
>


[*] (fnc) ARC_DOZIP : Create or update a zip archive
Related: ARC_UNZIP, ARC_INF

< 1.ARC_DOZIP - USE: Create

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ARCHIVE|symb||Archive name||
PATH|Symb||Source Directory||YES
FILE|slist||List of files to zip||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
°n=ARC_DOZIP(“test.zip”,”sourcedir”, “file1”,”File2” );
>


< 2.ARC_DOZIP - USE: Insert or update

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ARCHIVE|PTR||To a ARC-ZIP||
PATH|Symb||Source Directory|From PTR|YES
FILE|slist||List of files to zip||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|NV|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
°z=ARC_UNZIP(“test.zip”);
°n=ARC_DOZIP(z°,”sourcedir”, “file1”,”File2”);
>


[*] (fnc) ARC_INF : Get information from an archive
Related: ARC_DOZIP, ARC_INF, ARC_UNZIP

< 1.ARC_INF - USE: From a name

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ARCHIVE|symb||Archive name||
WHT|Symb|£DIR;£DIRPTH|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
°ls=ARC_INF(“test.zip”,£DIR); 
°ls=ARC_INF(“test.zip”,£DIRPTH); !! The internal Path is normalizes with \;
>


< 2.ARC_INF - USE: From an ARC PTR

[PARAMETER|TYPE|VALUES|COMMENT|DEFAULT|OPTIONAL]
ARCHIVE|symb||Archive name||
WHT|Symb|£ARC(name); £PTH(directory); £DIR(LIS of files);£DIRPTH(LIS of files with path)|||YES

[RETURN|TYPE|VALUES|COMMENT]
RES|Symb |PTR|

[OnError|TYPE|VALUES|COMMENT]
RES|symb|NULL

[EXAMPLE]
°z=ARC_UNZIP(“test.zip”);

°ls=ARC_INF(°z,£DIR); 
°ls=ARC_INF(°z,£DIRPTH); !! The internal Path is normalizes with \;
>


[*] (Page 0 of 506) POWER-KI : Page 0 of 506
Remark: confidential

[*] (Page 0 of 506) POWER-KI : Page 0 of 506
Remark: confidential

< CORE - LIB 
[*] (Page 0 of 506) POWER-KI : Page 0 of 506
Remark: confidential

[*] (POWER-KI) Page 2 of 506 : POWER-KI
Related: Library Reference
Remark: xplab-pxxx.xx-d-xxx-#-xx-xxxxxxxx-xx-1.0.0-en
